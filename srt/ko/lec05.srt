1
00:00:10,000 --> 00:00:19,000
좋아요. 이번 강의는 선형대수학(Linear Algebra) 제5강입니다. 이번 강의로 이 장이 마무리돼요.

2
00:00:19,000 --> 00:00:24,000
이 장의 마지막 절은 2.7인데요, 여기서 순열(Permutations)을 다루고,

3
00:00:24,000 --> 00:00:36,000
그건 지난 강의의 마지막에서 설명했죠. 그리고 전치(Transposes)도 지난 시간에 나왔어요.

4
00:00:36,000 --> 00:00:42,000
이 둘에 대해서 조금 더 다룰 게 있어요 — 순열과 전치 말이죠.

5
00:00:42,000 --> 00:00:48,000
그런데 오늘 강의의 핵심은, 어떻게 보면 선형대수학의 진짜 시작점이라고 할 수 있는 부분이에요.

6
00:00:48,000 --> 00:01:06,000
벡터 자체를 넘어서, 벡터공간(Vector Spaces), 그리고 그 부분공간(Subspaces)을 보는 더 넓은 시야를 갖는 부분이죠.

7
00:01:06,000 --> 00:01:13,000
우리는 지금 강의 진도보다 약간 앞서 있어요. 좋은 일이죠, 왜냐하면 이제부터 할 일이 많아지니까요.

8
00:01:13,000 --> 00:01:22,000
자, 그럼 순열부터 시작해봅시다.

9
00:01:22,000 --> 00:01:36,000
이 순열은요, P 행렬들이고, 행 교환(Row Exchanges)을 수행하는 행렬들이에요.

10
00:01:36,000 --> 00:01:52,000
그리고 우리는 이런 행렬들이 필요할 수 있어요. A라는 아주 좋은 행렬이 있다고 할게요 — 역행렬도 존재하고, Ax = b를 풀 수 있죠.

11
00:01:52,000 --> 00:02:00,000
그런데 그걸 풀기 위해서 — 우리는 이런 자유도가 있어야 해요.

12
00:02:00,000 --> 00:02:05,000
피벗(pivot) 자리에 0이 나타나면, 그걸 다른 행과 바꿔서 0이 아닌 수로 바꿔줘야 하죠.

13
00:02:05,000 --> 00:02:12,000
그래야 올바른 피벗을 갖게 되니까요.

14
00:02:12,000 --> 00:02:18,000
여러분은 이런 과정을 이미 본 적이 있을 거예요. 지금은 이 아이디어들을 정리하고자 해요.

15
00:02:18,000 --> 00:02:24,000
원칙적으로는, 두 번 이상의 행 교환이 필요할 수도 있어요.

16
00:02:24,000 --> 00:02:41,000
그러니까 이 이론을 완성하려면, A 행렬을 받아서 소거를 시작했는데 중간에 행을 교환해야 했고, 그걸 하고 나서 마무리했다는 가능성을 포함해야 해요.

17
00:02:41,000 --> 00:02:49,000
좋아요. 제가 지금 말하고 싶은 건 — 이걸 아주 깊게 다루진 않겠지만 —

18
00:02:49,000 --> 00:02:54,000
A = LU라는 식이 있을 때, 행 교환이 들어오면 어떻게 되는가예요.

19
00:02:54,000 --> 00:02:59,000
A = LU는 —

20
00:02:59,000 --> 00:03:05,000
L은 대각선에 1이 있고, 그 위는 0이고, 그 아래는 곱셈 계수들이 있는 행렬이었죠.

21
00:03:05,000 --> 00:03:13,000
U는 아래쪽이 0인 상삼각 행렬이고요.

22
00:03:13,000 --> 00:03:19,000
이건 오직 특정한 경우에만 가능한 형태예요.

23
00:03:19,000 --> 00:03:26,000
즉, 소거 과정을 이렇게 묘사하는 건 P, 즉 행 교환이 없을 때만 해당돼요.

24
00:03:26,000 --> 00:03:33,000
이제 저는 "행 교환이 있을 때는 어떻게 하지?" 라는 걸 말하고 싶은 거예요.

25
00:03:33,000 --> 00:03:40,000
A = LU라는 식에서, P가 항등행렬(identity matrix)이었던 경우죠.

26
00:03:40,000 --> 00:03:47,000
행의 순서가 이미 좋았기 때문에 그대로 놔뒀던 거예요. 여기서 현실적인 예를 하나 덧붙이자면요,

27
00:03:47,000 --> 00:03:55,000
Matlab은 소거를 할 때, 단지 피벗이 0이 아니냐만 체크하는 게 아니에요.

28
00:03:55,000 --> 00:04:09,000
Matlab은 피벗이 충분히 "큰 수"인지도 봐요. 작은 피벗은 싫어하죠. 수치적으로 불안정하거든요.

29
00:04:09,000 --> 00:04:16,000
0에 가까운 피벗은 수치적으로 문제가 돼요. 그래서 Matlab은 Ax = b를 풀라고 하면,

30
00:04:16,000 --> 00:04:23,000
필요 없다고 생각되는 경우에도 행 교환을 몇 번 하게 돼요.

31
00:04:23,000 --> 00:04:31,000
수학적으로는 안 해도 되지만, 수치적 정확도를 위해선 필요하죠.

32
00:04:31,000 --> 00:04:45,000
우리는 수학적인 관점에서 보고 있으니까, 정말 필요할 때만 행 교환을 하도록 해요. 하지만 필요할 수도 있어요.

33
00:04:45,000 --> 00:04:56,000
그리고 그 결과가 바로 여기 숨겨져 있어요. 이게 핵심이에요.

34
00:04:56,000 --> 00:05:12,000
행 교환을 포함한 소거 과정의 묘사는 이렇게 됩니다: A = LU가 아니라, PA = LU.

35
00:05:12,000 --> 00:05:18,000
여기서 P는 행을 교환해주는 행렬이에요. 실제로 행들을 올바른 순서로 정렬해줘요.

36
00:05:18,000 --> 00:05:32,000
즉, 피벗 자리에 0이 나타나지 않도록 해주죠. 그래서 L과 U가 위에 나왔던 것처럼 잘 나오게 돼요.

37
00:05:32,000 --> 00:05:39,000
이게 핵심이에요. 사실 이걸 길게 설명하고 싶진 않아요.

38
00:05:39,000 --> 00:05:47,000
Permutation Matrix — 순열 행렬에 대해 얘기해볼게요. 여러분은 지난 시간에 배웠을 거예요.

39
00:05:47,000 --> 00:05:57,000
순열 행렬의 주요 특성들을 다시 상기시키고,

40
00:05:57,000 --> 00:06:03,000
그리고 이 분해(PA = LU)를 일반적인 형태로 남겨둘게요.

41
00:06:03,000 --> 00:06:17,000
모든 가역행렬 A에 대해 이게 성립해요.

42
00:06:17,000 --> 00:06:30,000
거의 대부분의 경우엔 P가 필요 없어요. 하지만 일부 경우엔 행 교환이 필요하고, 그럴 땐 이렇게 처리하는 거예요.

43
00:06:30,000 --> 00:06:46,000
자, 마지막으로 P가 뭔지 다시 떠올려 봐요.

44
00:06:46,000 --> 00:06:56,000
순열 P는, 항등행렬에서 행의 순서만 바꾼 형태예요.

45
00:06:56,000 --> 00:07:02,000
그냥 그대로 두는 경우도 포함되죠. 즉, 항등행렬도 하나의 순열이에요.

46
00:07:02,000 --> 00:07:08,000
그건 가장 기본적인 순열 행렬이에요 — 아무 일도 안 하는 순열이죠.

47
00:07:08,000 --> 00:07:21,000
그리고 두 개의 행을 바꾸는 행렬, 세 개, 네 개의 행을 바꾸는 행렬도 있어요.

48
00:07:21,000 --> 00:07:35,000
만약 4개의 행이 있다면, 그걸 한 바퀴 돌리는 순환 순열도 있을 수 있어요. 1→2, 2→3, 3→4, 4→1처럼요.

49
00:07:35,000 --> 00:07:41,000
혹은 1과 2, 3과 4를 각각 바꾸는 식도 있겠죠.

50
00:07:41,000 --> 00:07:46,000
굉장히 다양한 경우의 수가 생겨요. 그럼 그 수는 얼마나 될까요?

51
00:07:46,000 --> 00:07:56,000
정답은 팩토리얼(factorial)이에요. n × (n-1) × (n-2) × ... × 1.

52
00:07:56,000 --> 00:08:05,000
이건 가능한 재배열의 수를 의미해요.

53
00:08:05,000 --> 00:08:15,000
즉, n × n 순열 행렬의 개수예요.

54
00:08:15,000 --> 00:08:32,000
그리고 이런 행렬들은 모두, 다시 원래 순서로 되돌릴 수 있기 때문에 역행렬이 존재해요.

55
00:08:32,000 --> 00:08:46,000
행을 다시 제자리로 돌리는 행렬이 있으니까요. 그게 바로 P의 전치(transpose)예요.

56
00:08:46,000 --> 00:08:57,000
P에 전치를 곱해보면, 1들이 서로 맞아 떨어져서 항등행렬이 나오게 돼요.

57
00:08:57,000 --> 00:09:02,000
우리는 이런 성질이 좋은 행렬들에 관심이 많을 거예요.

58
00:09:02,000 --> 00:09:09,000
이를 다른 말로 표현하면, Pᵀ × P = I 라는 식이죠.

59
00:09:09,000 --> 00:09:25,000
이건 곧, 전치가 역행렬이라는 걸 의미해요.

60
00:09:25,000 --> 00:09:42,000
우리는 이런 행렬에 관심이 있어요. 단지 순열뿐만 아니라, 다른 경우도 포함되지만 지금 중요한 건, 순열 행렬이 그런 특수 행렬들의 중심에 있다는 거예요.

61
00:09:42,000 --> 00:09:47,000
자, 이제 우리는 그 개수도 알아요.

62
00:09:47,000 --> 00:10:09,000
4×4 순열은 총 24개였죠. 5!은 120이니까, 5×24 = 120이 되겠네요. 5×5 순열을 전부 나열하는 건 별로 재미 없을 거예요.

63
00:10:09,000 --> 00:10:15,000
좋아요, 여기까지가 순열이에요.

64
00:10:15,000 --> 00:10:20,000
그리고 이제 2.7절에는 전치(transpose)에 대한 설명도 들어 있어요.

65
00:10:20,000 --> 00:10:30,000
그걸 이제 마무리해볼게요. 우선, 아직 칠판에 전치된 행렬을 안 써봤네요?

66
00:10:30,000 --> 00:10:39,000
한 번 써봐야겠어요. 예를 들어 (1 2 4; 3 3 1) 같은 행렬이 있다고 해봅시다.

67
00:10:39,000 --> 00:10:47,000
직사각형 행렬이죠. 3행 2열이에요.

68
00:10:47,000 --> 00:10:53,000
이걸 전치하면 어떻게 될까요?

69
00:10:53,000 --> 00:10:59,000
전치 기호로 T를 쓰겠습니다. Matlab에서는 ' (프라임)을 써요.

70
00:10:59,000 --> 00:11:07,000
결과는 — 여기 써볼게요. 원래는 3행 2열이었는데,

71
00:11:07,000 --> 00:11:13,000
전치하면 2행 3열이 되죠.

72
00:11:13,000 --> 00:11:20,000
즉, 더 짧고 더 넓어진 형태예요.

73
00:11:20,000 --> 00:11:25,000
물론, 열(column)은 행(row)이 되고 —

74
00:11:25,000 --> 00:11:36,000
각 열이 행으로 바뀌어요. 동시에, 행도 열로 바뀌어요.

75
00:11:36,000 --> 00:11:41,000
이 행도 열이 된 거죠. 자, 그럼 일반적인 전치 공식은 뭘까요?

76
00:11:41,000 --> 00:11:48,000
전치는 —

77
00:11:48,000 --> 00:11:54,000
지금 숫자로 본 걸 기호로 표현하면 똑같은 거예요.

78
00:11:54,000 --> 00:12:04,000
물론 숫자로 보는 게 가장 직관적이지만, 기호로도 써볼게요.

79
00:12:04,000 --> 00:12:10,000
A의 전치에서, i행 j열의 값은 뭐가 될까요?

80
00:12:10,000 --> 00:12:16,000
그 값은 A에서 나온 거예요.

81
00:12:16,000 --> 00:12:22,000
주대각선(main diagonal)을 기준으로 뒤집어서 나온 거죠.

82
00:12:22,000 --> 00:12:28,000
그리고 실제로, 그건 A의 원소 중 J행 I열에 있던 값이에요.

83
00:12:28,000 --> 00:12:34,000
그래서 행과 열의 인덱스가 서로 바뀐다는 거예요.

84
00:12:34,000 --> 00:12:45,000
행 번호가 열 번호가 되고, 열 번호가 행 번호가 되는 거죠. 문제없어요.

85
00:12:45,000 --> 00:12:52,000
좋아요. 이제 특별한 — 가장 좋은 행렬들을 볼게요.

86
00:12:52,000 --> 00:12:58,000
많은 응용 분야에서, 대칭 행렬(symmetric matrix)이 나타나요.

87
00:12:58,000 --> 00:13:07,000
그래서 대칭 행렬에 주목해 볼게요.

88
00:13:07,000 --> 00:13:16,000
'symmetric'라는 말은 무슨 뜻일까요? 이 말은, 전치(transpose)해도 행렬이 바뀌지 않는다는 뜻이에요.

89
00:13:16,000 --> 00:13:21,000
A의 전치가 A와 같다는 거죠.

90
00:13:21,000 --> 00:13:29,000
예제를 하나 들어보죠. 대칭인 행렬을 생각해 볼게요.

91
00:13:29,000 --> 00:13:43,000
대각선 위에 어떤 값이든 괜찮아요 — 하지만 대각선 위쪽에 있는 값이, 아래쪽에도 있어야 해요. 예를 들어 1이 위에 있으면, 그 아래도 1, 7이 있으면 아래도 7, 9도 마찬가지죠.

92
00:13:43,000 --> 00:13:52,000
이런 게 대칭 행렬이에요. 전 숫자를 모두 양수로 썼지만,

93
00:13:52,000 --> 00:13:58,000
그게 핵심은 아니에요. 핵심은, 전치를 해도 똑같은 행렬이 다시 나온다는 거예요.

94
00:13:58,000 --> 00:14:07,000
즉, Aᵀ = A. 이게 대칭 행렬의 특징이에요. 여기서 제가 말씀드리고 싶은 건,

95
00:14:07,000 --> 00:14:14,000
전치해도 바뀌지 않는 행렬들의 집합이 있다는 거예요.

96
00:14:14,000 --> 00:14:22,000
그리고 이건 쉽게 알아볼 수 있어요.

97
00:14:22,000 --> 00:14:36,000
예전엔 전치가 역행렬이 되는 경우도 봤죠. 그건 중요하지만, 이해하기 쉬운 건 아니에요.

98
00:14:36,000 --> 00:14:42,000
지금의 경우처럼, 전치해도 그대로 나오는 경우는 확실히 쉽게 볼 수 있어요.

99
00:14:42,000 --> 00:14:49,000
좋아요. 그럼 이런 행렬이 어떻게 생길 수 있는지 볼까요?

100
00:14:49,000 --> 00:14:55,000
예를 들어, 아까 본 저 행렬은 절대 대칭이 아니었죠.

101
00:14:55,000 --> 00:15:06,000
전치해도 모양 자체가 다르잖아요 — 직사각형이니까, 전치하면 눕게 되죠.

102
00:15:06,000 --> 00:15:11,000
하지만 이걸 대칭 행렬로 바꿀 수 있는 방법이 있어요.

103
00:15:11,000 --> 00:15:17,000
곱해보세요. 이 직사각형 행렬 — 이름을 R이라고 할게요. (rectangular)

104
00:15:17,000 --> 00:15:22,000
그럼 Rᵀ은 그 전치(transpose)겠죠. 이 둘을 곱하면,

105
00:15:22,000 --> 00:15:32,000
대칭 행렬이 나올 거예요.

106
00:15:32,000 --> 00:15:44,000
이걸 숫자로 계산해보면 대칭이 되는 걸 볼 수 있고, 왜 그런지도 생각해볼 수 있어요.

107
00:15:44,000 --> 00:15:52,000
중요한 건, RᵀR은 항상 대칭이라는 거예요.

108
00:15:52,000 --> 00:15:57,000
좋아요?

109
00:15:57,000 --> 00:16:02,000
지금 계산해보려는 건 지금 우리가 만든 이 RᵀR이에요.

110
00:16:02,000 --> 00:16:09,000
Rᵀ의 열은 1 2 4, 그리고 3 3 1 이었죠.

111
00:16:09,000 --> 00:16:16,000
제가 그걸 Rᵀ이라 불렀고, 다른 건 R이라고 했어요. 맞죠?

112
00:16:16,000 --> 00:16:22,000
그럼 계산해봅시다. 위쪽 원소는 10이 나와요.

113
00:16:22,000 --> 00:16:30,000
그 옆은 2, 9, 다음은 11, 그 다음은 4, 3, 7이 나와요.

114
00:16:30,000 --> 00:16:37,000
그 11은 1×3 + 3×3에서 나온 거죠? 1행 2열에서요.

115
00:16:37,000 --> 00:16:43,000
그럼 반대쪽은요? 2행 1열에서 나온 값은?

116
00:16:43,000 --> 00:16:50,000
결과는 똑같죠. 1×3 + 3×3이니까요. 순서만 바뀐 거예요.

117
00:16:50,000 --> 00:16:56,000
결과는 11이에요. 이게 바로 대칭성(symmetric)의 핵심이죠.

118
00:16:56,000 --> 00:17:02,000
이제 나머지도 채워볼 수 있어요.

119
00:17:02,000 --> 00:17:10,000
그 7도 아래쪽에 반복되죠. 그 외에 4개의 숫자만 더 있으면 돼요.

120
00:17:10,000 --> 00:17:16,000
1×4 + 3×1에서 나온 7은 4×1 + 1×3으로도 다시 나오죠.

121
00:17:16,000 --> 00:17:24,000
이게 잘 작동하는 걸 알 수 있죠?

122
00:17:24,000 --> 00:17:29,000
이걸 기호로도 볼 수 있어요. 행렬 언어로 표현하면요.

123
00:17:29,000 --> 00:17:35,000
그 7은 우연히 나온 게 아니에요.

124
00:17:35,000 --> 00:17:40,000
11도 마찬가지예요.

125
00:17:40,000 --> 00:17:49,000
그럼 이걸 전치했을 때 대칭인지 어떻게 알 수 있을까요?

126
00:17:49,000 --> 00:17:54,000
전치해봤을 때, 그 결과가 원래 행렬과 같다면 대칭이죠.

127
00:17:54,000 --> 00:17:59,000
그럼 RᵀR을 전치해보죠.

128
00:17:59,000 --> 00:18:09,000
왜 그런 결과가 나오는지를 볼 수 있어요.

129
00:18:09,000 --> 00:18:19,000
이게 대칭임을 보이는 유일한 방법은 전치를 해보고 바뀌었는지를 확인하는 거예요.

130
00:18:19,000 --> 00:18:27,000
좋아요, 그럼 RᵀR의 전치를 해봅시다.

131
00:18:27,000 --> 00:18:33,000
이건 전치 규칙(transpose rule) 연습이에요.

132
00:18:33,000 --> 00:18:44,000
규칙은, 곱의 전치는 순서를 바꿔서 각각 전치하는 거예요.

133
00:18:44,000 --> 00:18:51,000
즉, 전치된 순서로 두 행렬이 나와요.

134
00:18:51,000 --> 00:18:56,000
첫 번째는 뒤쪽 행렬을 전치한 것이고,

135
00:18:56,000 --> 00:19:03,000
두 번째는 앞쪽 행렬을 전치한 것이죠.

136
00:19:03,000 --> 00:19:15,000
그럼 여기서 Rᵀᵀ은 뭘까요?

137
00:19:15,000 --> 00:19:22,000
다 같이 말하지는 마세요. Rᵀᵀ은 한 번 뒤집고, 또 한 번 뒤집은 거죠.

138
00:19:22,000 --> 00:19:28,000
결국 원래대로 돌아오니까 R이죠.

139
00:19:28,000 --> 00:19:34,000
이게 핵심이에요. 시작한 행렬을 전치하고 또 전치하면 원래 행렬이 나오는 거예요.

140
00:19:34,000 --> 00:19:46,000
그래서 숫자 없이도 확인이 되죠.

141
00:19:46,000 --> 00:19:52,000
두 줄짜리 계산으로 항상 대칭 행렬이 나온다는 걸 보여줬어요.

142
00:19:52,000 --> 00:20:00,000
그리고 실제로 많은 응용에서 이런 방식으로 대칭 행렬이 생겨나요.

143
00:20:00,000 --> 00:20:07,000
좋아요. 오늘 저는 순열(Permutation), 전치(Transpose), 대칭성(Symmetry)에 대해 설명했고,

144
00:20:07,000 --> 00:20:21,000
이제 3장을 시작할 준비가 됐어요. 잠깐 숨 돌릴까요 —

145
00:20:21,000 --> 00:20:31,000
녹화 테이프는 쉬지 않지만 강사는 좀 쉬어야겠네요. 왜냐하면 이제 벡터공간(Vector Spaces)을 설명해야 하니까요.

146
00:20:31,000 --> 00:20:38,000
자, 이제 집중해 주세요.

147
00:20:38,000 --> 00:20:47,000
벡터공간이란 무엇인가요?

148
00:20:47,000 --> 00:21:01,000
그리고 부분공간(Subspaces)은 뭘까요? 우리가 주로 하는 연산은 뭐죠?

149
00:21:01,000 --> 00:21:07,000
벡터로 뭘 하죠? 더해요. 벡터끼리 더하는 걸 알고 있죠.

150
00:21:07,000 --> 00:21:13,000
또 숫자를 곱해요. 보통 스칼라(Scalar)라고 하죠.

151
00:21:13,000 --> 00:21:24,000
벡터 V가 있으면, 3V가 뭔지 알고 있어요. 벡터 V와 W가 있으면, V + W가 뭔지도 알아요.

152
00:21:24,000 --> 00:21:29,000
이 두 가지 연산이 기본이에요.

153
00:21:29,000 --> 00:21:35,000
어떤 집합이 벡터공간이라고 말하려면 이 연산들을 할 수 있어야 해요.

154
00:21:35,000 --> 00:21:44,000
즉, 덧셈과 스칼라 곱이 가능해야 하고, 어떤 기본적인 규칙들을 만족해야 해요.

155
00:21:44,000 --> 00:22:06,000
좋아요. 그럼 예시부터 시작해 볼게요. 이제 벡터공간에 대해 이야기합니다.

156
00:22:06,000 --> 00:22:14,000
먼저, '공간(space)'이라는 말이 무슨 뜻인지 다시 말할게요. '공간'이란 말은 저에게

157
00:22:14,000 --> 00:22:19,000
벡터들이 모인 어떤 집합을 의미해요 — 그냥 아무 벡터 집합이 아니라,

158
00:22:19,000 --> 00:22:28,000
벡터공간이라는 말은 벡터에 적합한 연산이 가능한 공간이어야 해요.

159
00:22:28,000 --> 00:22:37,000
벡터끼리 더할 수 있어야 하고, 숫자를 곱할 수 있어야 하죠.

160
00:22:37,000 --> 00:22:43,000
선형 결합(linear combination)을 만들 수 있어야 해요. 그런 건 어디서 봤죠?

161
00:22:43,000 --> 00:22:48,000
우리는 R²에서 그런 걸 봤어요.

162
00:22:48,000 --> 00:22:54,000
그럼 그게 어떤 벡터공간인지 봅시다.

163
00:22:54,000 --> 00:22:59,000
R²는 실수(real number) 두 개를 의미해요.

164
00:22:59,000 --> 00:23:11,000
즉, 두 실수로 이루어진 벡터들이라는 뜻이에요.

165
00:23:11,000 --> 00:23:30,000
예를 들어 이런 벡터들 — |3; 2|, |0; 0|, |π; e| 등등이죠.

166
00:23:30,000 --> 00:23:35,000
이런 식으로요.

167
00:23:35,000 --> 00:23:44,000
그리고 이건 아주 자연스러운 거예요. 이제 대수부터 봅시다.

168
00:23:44,000 --> 00:23:50,000
대수라는 건, 이런 벡터들에 무슨 연산을 할 수 있느냐예요. 더할 수 있어요.

169
00:23:50,000 --> 00:23:58,000
이 벡터와 저 벡터를 더할 수 있어요.

170
00:23:58,000 --> 00:23:58,000
어떻게 더하죠? 각 성분별로 더하죠. (3,2) + (0,0)은 (3,2).

171
00:23:58,000 --> 00:24:05,000
(3,2) + (π,e)는 (3+π, 2+e)가 되죠.

172
00:24:05,000 --> 00:24:11,000
아, 이게 뭘 하는지 아시죠. 그리고 이 벡터에 대한 그림도 떠오를 거예요.

173
00:24:11,000 --> 00:24:19,000
여기 벡터 (3,2)가 있어요. 그림에는 보통 화살표가 그려지죠.

174
00:24:19,000 --> 00:24:24,000
그리고 벡터 (0,0)는 굉장히 중요한 벡터예요 — 아마 가장 중요한 벡터일 거예요.

175
00:24:24,000 --> 00:24:29,000
그 자리에 있어야 하고, 당연히 화살표는 거의 없겠죠.

176
00:24:29,000 --> 00:24:35,000
π는... 기억해야겠네요 — π는 대략 3보다 약간 크고,

177
00:24:35,000 --> 00:24:41,000
e는 대략 2보다 약간 크죠. 그러니까 아마 (π,e)는 이쯤일 거예요.

178
00:24:41,000 --> 00:24:47,000
π와 e 벡터는 제가 그려본 적 없네요. 하지만 아주 자연스러워요.

179
00:24:47,000 --> 00:24:55,000
첫 번째 성분은 수평 방향이고,

180
00:24:55,000 --> 00:25:02,000
두 번째 성분은 수직으로 올라가는 방향이에요.

181
00:25:02,000 --> 00:25:07,000
좋아요. 전체 평면이 R²입니다.

182
00:25:07,000 --> 00:25:14,000
그러니까 R²는, 말하자면, 평면이에요.

183
00:25:14,000 --> 00:25:24,000
xy 평면이죠. 다들 그렇게 생각하죠.

184
00:25:24,000 --> 00:25:32,000
하지만 핵심은, 이건 벡터공간이라는 거예요. 왜냐하면 모든 벡터들이 그 안에 들어 있으니까요.

185
00:25:32,000 --> 00:25:39,000
그 중 하나를 빼버리면 — 예를 들어 (0,0)을 뺀다고 해봅시다.

186
00:25:39,000 --> 00:25:46,000
xy 평면에서 점 하나를 뺀, 구멍 난 평면을 생각해 보세요.

187
00:25:46,000 --> 00:25:52,000
즉, 원점을 뺀다면요. 그건 끔찍한 일이에요. 왜일까요?

188
00:25:52,000 --> 00:25:59,000
왜 원점이 꼭 있어야 할까요? 왜냐하면 다른 벡터들이 있다면,

189
00:25:59,000 --> 00:26:05,000
예를 들어 이 (3,2) 벡터가 있다면 — 이걸 어떤 수로든 곱할 수 있어야 하니까요. 0도 포함해서요.

190
00:26:05,000 --> 00:26:12,000
0으로 곱하는 것도 가능해야 하고, 결과 벡터도 그 공간 안에 있어야 해요.

191
00:26:12,000 --> 00:26:18,000
그 점이 없으면 안 돼요.

192
00:26:18,000 --> 00:26:23,000
그리고 (3,2)와 그 반대인 (-3,-2)를 더했을 때,

193
00:26:23,000 --> 00:26:29,000
다시 원점으로 돌아가야 해요.

194
00:26:29,000 --> 00:26:36,000
원점 없이 벡터공간은 성립하지 않아요. 모든 벡터공간에는 0 벡터가 있어야 해요.

195
00:26:36,000 --> 00:26:42,000
좋아요, 이건 쉬운 예제예요. 그림으로 쉽게 이해할 수 있는 벡터공간이죠.

196
00:26:42,000 --> 00:26:50,000
R³도 마찬가지로 쉽습니다.

197
00:26:50,000 --> 00:27:09,000
위로 좀 올라가볼게요. 이건 — R³는 3차원 벡터 전체를 말해요. 또는 세 개의 실수 성분을 가진 벡터들이죠.

198
00:27:09,000 --> 00:27:15,000
좋아요.

199
00:27:15,000 --> 00:27:21,000
우리가 같은 얘기를 하고 있는지 확실히 하려고,

200
00:27:21,000 --> 00:27:29,000
(3,2,0) 벡터를 한번 봅시다.

201
00:27:29,000 --> 00:27:38,000
이건 R²에 속하나요, R³에 속하나요? 명백하게 R³에 속하죠.

202
00:27:38,000 --> 00:27:43,000
성분이 3개예요. 하나가 0이긴 해도 괜찮아요. 0도 실수니까요.

203
00:27:43,000 --> 00:27:51,000
그래서 이건 R³에 속하는 벡터예요. 혼동하면 안 돼요.

204
00:27:51,000 --> 00:27:57,000
벡터를 정확히 구분해야 하고, Rⁿ도 정확히 알아야 해요. 그럼 Rⁿ은 뭘까요?

205
00:27:57,000 --> 00:28:05,000
Rⁿ — 이건 아주 중요한 예제예요. 성분이 n개인 모든 벡터들을 말해요.

206
00:28:05,000 --> 00:28:11,000
그리고 전부 열 벡터(column vector)로 쓰고 있어요.

207
00:28:11,000 --> 00:28:17,000
그 규칙을 따르겠습니다. 열 벡터로 쓰고, 성분들은 실수입니다.

208
00:28:17,000 --> 00:28:24,000
나중엔 복소수와 복소 벡터도 다루겠지만, 그건 훨씬 나중 일이에요.

209
00:28:24,000 --> 00:28:31,000
좋아요. 이건 벡터공간이에요.

210
00:28:31,000 --> 00:28:44,000
이제 벡터공간에 대해 뭘 말씀드려야 할까요? 제가 가장 중요한 말은 했어요 — R²의 어떤 두 벡터를 더해도 여전히 R²에 있고,

211
00:28:44,000 --> 00:28:50,000
어떤 수를 곱해도 여전히 R²에 있어요.

212
00:28:50,000 --> 00:28:55,000
어떤 조합을 만들어도 R²에 있어요. Rⁿ도 마찬가지예요.

213
00:28:55,000 --> 00:29:02,000
그리고 이제 솔직히 말씀드려야겠죠. 이러한 덧셈과 곱셈 연산은

214
00:29:02,000 --> 00:29:08,000
몇 가지 규칙을 따라야 해요.

215
00:29:08,000 --> 00:29:15,000
예를 들어, 우리가 임의로 (3,2) + (π,e) = (0,0)이라고 하면 안 돼요.

216
00:29:15,000 --> 00:29:22,000
그건 아니에요. (3,2) + (-3,-2)가 (0,0)인 건 맞지만요.

217
00:29:22,000 --> 00:29:32,000
사실 책에는 덧셈과 곱셈이 따라야 할 8가지 규칙이 나와 있어요.

218
00:29:32,000 --> 00:29:38,000
하지만 Rⁿ에서는 그 규칙들을 다 만족해요. 보통 문제는 그 8가지 규칙이 아니에요.

219
00:29:38,000 --> 00:29:50,000
문제는, 덧셈이나 곱셈을 했을 때 그 공간 안에 여전히 있는지예요.

220
00:29:50,000 --> 00:29:55,000
그게 안 되는 예를 하나 보여드릴게요.

221
00:29:55,000 --> 00:30:05,000
그래서 이건 벡터공간이 아닌 경우가 됩니다.

222
00:30:05,000 --> 00:30:11,000
xy 평면, 즉 R²는 벡터공간이에요.

223
00:30:11,000 --> 00:30:17,000
그런데 이제 그 일부만 가져올게요. 예를 들어 이 부분만요.

224
00:30:17,000 --> 00:30:24,000
벡터 성분이 둘 다 0 이상인 1사분면 부분만 취한다고 해봅시다.

225
00:30:24,000 --> 00:30:37,000
그럼 이런 경우엔 덧셈은 안전할까요?

226
00:30:37,000 --> 00:30:45,000
예, 덧셈은 괜찮아요. (3,2)와 (5,6)을 더하면 여전히 1사분면에 있어요.

227
00:30:45,000 --> 00:30:54,000
덧셈은 문제없어요. 하지만 스칼라 곱에서는 큰 문제가 생깁니다.

228
00:30:54,000 --> 00:31:02,000
왜냐하면 음수를 곱하면 그 공간을 벗어나기 때문이죠.

229
00:31:02,000 --> 00:31:08,000
(3,2)에 -5를 곱하면 저 아래쪽 어딘가로 가버려요.

230
00:31:08,000 --> 00:31:14,000
그래서 이건 벡터공간이 아니에요. 왜냐하면 닫힘(closed) 조건을 만족하지 않기 때문이죠.

231
00:31:14,000 --> 00:31:19,000
실수 전체에 대해 곱셈이 닫혀 있지 않아요.

232
00:31:19,000 --> 00:31:27,000
즉, 벡터공간은 벡터의 덧셈과 곱셈에 대해 닫혀 있어야 해요.

233
00:31:27,000 --> 00:31:37,000
다시 말해, 선형결합(linear combination)이 가능해야 해요. 그러니까, 몇 개의 벡터를 주면 —

234
00:31:37,000 --> 00:31:47,000
이제 정말 중요한 예로 갑니다. Rⁿ이야말로 가장 중요한 벡터공간이죠.

235
00:31:47,000 --> 00:31:52,000
그런데 우리는 Rⁿ 내부의 부분 벡터공간에도 관심을 가져요.

236
00:31:52,000 --> 00:32:01,000
규칙은 따르지만, Rⁿ 전체가 아니라 그 안의 일부인 거죠.

237
00:32:01,000 --> 00:32:10,000
아까 R²에서 시작해서,

238
00:32:10,000 --> 00:32:17,000
그 중 일부만 가져왔더니 벡터공간이 아니게 됐어요.

239
00:32:17,000 --> 00:32:25,000
그럼 이번엔 R²의 일부면서도 진짜 벡터공간인 경우를 보여드릴게요.

240
00:32:25,000 --> 00:32:31,000
그 공간 안에서 덧셈과 곱셈을 해도 여전히 그 공간 안에 머무는 경우요.

241
00:32:31,000 --> 00:32:40,000
그걸 우리는 부분공간(subspace)이라고 부릅니다. 앞서 말한 나쁜 예제를 이제 좋은 예제로 바꿔볼게요.

242
00:32:40,000 --> 00:32:50,000
R²에서 다시 시작해서, 이번에는 진짜 벡터공간인 예제를 봅시다.

243
00:32:50,000 --> 00:32:56,000
그러면 이건 R² 내부의 벡터공간이 될 거예요.

244
00:32:56,000 --> 00:33:03,000
그래서 우리는 그걸 R²의 부분공간이라고 부릅니다.

245
00:33:03,000 --> 00:33:09,000
좋아요. 뭘 할 수 있을까요?

246
00:33:09,000 --> 00:33:14,000
무언가 벡터 하나는 들어 있어야 해요. 예를 들어 이 벡터가 있다고 해봅시다.

247
00:33:14,000 --> 00:33:19,000
이 벡터가 내 부분공간에 포함돼 있다면,

248
00:33:19,000 --> 00:33:24,000
진짜 부분공간이라면 그와 관련된 다른 벡터들도 있어야 하겠죠?

249
00:33:24,000 --> 00:33:33,000
예를 들어 그걸 2배한 벡터도 있어야 하고,

250
00:33:33,000 --> 00:33:39,000
0배, 1/2배, 3/4배도 있어야 해요.

251
00:33:39,000 --> 00:33:44,000
-1/2배, -1배도 있어야 해요.

252
00:33:44,000 --> 00:33:52,000
모든 실수에 대해 곱해진 벡터가 있어야 해요. 즉, 그 벡터가 포함되어 있다면 그 벡터가 놓인 직선 전체가 있어야 해요.

253
00:33:52,000 --> 00:33:58,000
무슨 말인지 아시겠죠? 벡터 하나가 있으면

254
00:33:58,000 --> 00:34:09,000
그걸 포함하는 직선 전체가 있어야 해요. 그 선형 결합까지 포함되지 않으면 벡터공간이 안 돼요.

255
00:34:09,000 --> 00:34:15,000
이제 덧셈 조건도 확인해야겠죠.

256
00:34:15,000 --> 00:34:26,000
하지만 이 직선이라면 괜찮아요. 직선 위의 벡터끼리 더하면 여전히 직선 위에 있어요.

257
00:34:26,000 --> 00:34:45,000
예제입니다. 이건 부분공간의 예제예요 — 우리 예제는 R² 안의 직선이에요. 단, 아무 직선이 아니에요.

258
00:34:45,000 --> 00:34:56,000
이런 직선을 생각해보죠. 이 직선 위의 모든 벡터들 — 예: 이 벡터, 저 벡터, 또 다른 벡터들.

259
00:34:56,000 --> 00:35:05,000
제가 지금 연하게 그리고 있는 건 부분공간이 아닌 예제예요.

260
00:35:05,000 --> 00:35:15,000
왜냐하면 R² 안에서 부분공간이 되려면 그 직선은 반드시 원점을 지나야 해요.

261
00:35:15,000 --> 00:35:21,000
왜 이 직선은 안 될까요?

262
00:35:21,000 --> 00:35:27,000
점선(dashed line)으로 표시해볼게요.

263
00:35:27,000 --> 00:35:34,000
이 점선 위의 어떤 벡터에 0을 곱하면, 이 아래로 내려오게 돼요. 점선 위에 있지 않게 되죠.

264
00:35:34,000 --> 00:35:39,000
그러니까 0 벡터는 반드시 있어야 해요. 모든 부분공간에는 0 벡터가 반드시 있어야 해요.

265
00:35:39,000 --> 00:35:46,000
왜냐하면 어떤 벡터든 0을 곱했을 때 항상 0 벡터가 되기 때문이죠.

266
00:35:46,000 --> 00:35:51,000
좋아요. 이제 부분공간을 몇 개 만들어 보려 해요.

267
00:35:51,000 --> 00:35:59,000
R² 안에 있는 동안, 가능한 모든 경우를 한번 생각해보죠.

268
00:35:59,000 --> 00:36:07,000
R²에서는 경우가 그리 많지 않아요. 그럼 가능한 부분공간들은 뭐가 있을까요?

269
00:36:07,000 --> 00:36:16,000
지금부터 R²의 부분공간들을 나열해볼게요.

270
00:36:16,000 --> 00:36:23,000
첫 번째로 항상 가능한 경우는 —

271
00:36:23,000 --> 00:36:29,000
R² 전체, 전체 공간입니다.

272
00:36:29,000 --> 00:36:35,000
전체 공간도 자기 자신에 대한 부분공간으로 인정돼요. 항상 포함시켜야 해요.

273
00:36:35,000 --> 00:36:45,000
그리고 나머지들은 직선입니다 — 무한히 양쪽으로 뻗은 직선, 단, 원점을 지나야 해요.

274
00:36:45,000 --> 00:37:00,000
그건 마치 전체 공간과도 비슷하고 — 이건 2차원 전체 공간이죠.

275
00:37:00,000 --> 00:37:07,000
이건 일차원이라고 볼 수 있어요. 이 직선이 R¹과 같을까요? 아니요.

276
00:37:07,000 --> 00:37:14,000
겉보기엔 R¹과 매우 비슷해요. R¹도 직선이고, 이것도 직선이니까요.

277
00:37:14,000 --> 00:37:20,000
하지만 이건 R² 안의 직선이에요. 벡터들이 성분 두 개를 가지고 있어요.

278
00:37:20,000 --> 00:37:25,000
그래서 R¹과는 달라요. R¹에서는 벡터가 성분 하나만 가집니다.

279
00:37:25,000 --> 00:37:32,000
아주 비슷하긴 하지만, 같지는 않아요. 좋아요, 이제 세 번째 경우가 있어요.

280
00:37:32,000 --> 00:37:40,000
R²의 세 번째 부분공간은 —

281
00:37:40,000 --> 00:37:47,000
전체 공간도 아니고, 직선도 아니에요.

282
00:37:47,000 --> 00:38:01,000
더 작은 거예요. 바로 0 벡터 하나만 있는 경우예요.

283
00:38:01,000 --> 00:38:07,000
전 이 부분공간을 Z라고 부르기도 해요. Zero에서 따온 이름이죠. 직선은 L, 전체 평면은 R²라고 부를게요.

284
00:38:07,000 --> 00:38:14,000
자, 이제 0 벡터 하나만 있는 것도 괜찮은가를 봐야 해요.

285
00:38:14,000 --> 00:38:20,000
부분공간의 의미를 이해하려면 규칙을 알아야 하고 — 규칙을 안다는 건 곧 이런 것도 확인해야 해요.

286
00:38:20,000 --> 00:38:27,000
0 벡터 하나만 있는 경우도 규칙을 만족하는가?

287
00:38:27,000 --> 00:38:36,000
왜 그럴까요? 너무 당연해서 설명하기가 민망할 정도예요. 이걸 자기 자신과 더하면 그대로예요.

288
00:38:36,000 --> 00:38:44,000
17을 곱해도 여전히 그대로예요. 즉, 필요한 연산 — 덧셈, 스칼라 곱을 해도 여전히 그 공간 안에 있어요.

289
00:38:44,000 --> 00:38:50,000
어떤 연산을 해도 이 한 점을 벗어나지 않아요.

290
00:38:50,000 --> 00:38:57,000
그래서 이건 항상 유효한 가장 작은 부분공간이에요.

291
00:38:57,000 --> 00:39:02,000
가장 큰 부분공간은 전체 공간이고, 그 사이엔 —

292
00:39:02,000 --> 00:39:07,000
뭐든지 중간에 올 수 있겠죠.

293
00:39:07,000 --> 00:39:18,000
예를 들어, R³에서는 어떤 경우가 있을까요?

294
00:39:18,000 --> 00:39:23,000
3차원 공간에서는 한쪽 끝이 전체 공간 R³이고, 다른 쪽 끝은 0 벡터 하나예요.

295
00:39:23,000 --> 00:39:32,000
그 중간은? 원점을 지나는 평면이 하나 있고,

296
00:39:32,000 --> 00:39:43,000
또 원점을 지나는 직선도 있어요. 결국 R³에서는 네 가지가 가능한 거예요: 전체 공간, 평면, 직선, 그리고 0 벡터 하나.

297
00:39:43,000 --> 00:39:51,000
좋아요. 이제 개념은 잡히셨죠. 이제 진짜 중요한 질문은 —

298
00:39:51,000 --> 00:39:57,000
실제로 이런 부분공간들이 어디서 오는가? 행렬과 어떻게 연결되는가?

299
00:39:57,000 --> 00:40:06,000
그걸 이야기하려고 해요. 자, 이 행렬을 가져와 봅시다.

300
00:40:06,000 --> 00:40:17,000
그 행렬로부터 부분공간을 만들어보려고 해요.

301
00:40:17,000 --> 00:40:26,000
그 중 하나는 열(column)들로부터 나오는 부분공간이에요.

302
00:40:26,000 --> 00:40:34,000
이게 바로 중요한 부분공간입니다.

303
00:40:34,000 --> 00:40:40,000
행렬로부터 나오는 첫 번째 중요한 부분공간이죠 — 이 행렬을 다시 A라고 부를게요.

304
00:40:40,000 --> 00:40:48,000
A의 열들을 보는 겁니다.

305
00:40:48,000 --> 00:40:58,000
이 열들은 R³에 속해 있어요. R³ 안에 있는 벡터들이죠.

306
00:40:58,000 --> 00:41:04,000
그 열들이 내 부분공간 안에 있기를 원해요.

307
00:41:04,000 --> 00:41:11,000
하지만 열 두 개만 넣고 "부분공간이다"라고 말할 수는 없어요.

308
00:41:11,000 --> 00:41:16,000
그 열들을 포함하고 싶다면, 무엇까지 포함시켜야 할까요?

309
00:41:16,000 --> 00:41:25,000
덧셈이 가능해야 해요. 두 열을 더한 것도 있어야 해요.

310
00:41:25,000 --> 00:41:34,000
두 열의 합 — 예를 들어 (4,5,5) 같은 벡터도 포함돼야 해요.

311
00:41:34,000 --> 00:41:42,000
그리고 첫 번째 열에 세 번째 열을 세 배 곱해서 더한 벡터도 있어야 해요.

312
00:41:42,000 --> 00:41:48,000
0 벡터도 반드시 있어야 하고요.

313
00:41:48,000 --> 00:41:54,000
즉, 모든 선형결합이 포함돼야 해요.

314
00:41:54,000 --> 00:42:02,000
그래야 진짜 부분공간이 됩니다.

315
00:42:02,000 --> 00:42:14,000
다시 말해, 이 열들은 R³에 있는 벡터들이고, 그들의 모든 선형결합이 하나의 부분공간을 이룹니다.

316
00:42:14,000 --> 00:42:28,000
선형결합이란 건 뭐냐면, 하나에 어떤 수를 곱하고, 다른 것에도 어떤 수를 곱하고, 그걸 더하는 거예요.

317
00:42:28,000 --> 00:42:33,000
선형대수에서의 두 가지 연산 — 스칼라 곱과 벡터 덧셈이죠.

318
00:42:33,000 --> 00:42:46,000
이 모든 연산 결과들을 포함시키면 그건 자동으로 부분공간이 돼요.

319
00:42:46,000 --> 00:42:53,000
그리고 우리는 거기에 이름을 붙일 거예요 — 바로 열공간(column space) 입니다.

320
00:42:53,000 --> 00:43:01,000
열공간.

321
00:43:01,000 --> 00:43:07,000
기호로는 C(A)라고 씁니다. C는 column의 첫 글자예요.

322
00:43:07,000 --> 00:43:15,000
여기에 중요한 개념이 숨어 있어요 —

323
00:43:15,000 --> 00:43:22,000
오늘 강의의 중심 개념은 이거예요:

324
00:43:22,000 --> 00:43:29,000
벡터 몇 개만으로는 만족하지 않아요. 우리는 벡터의 공간이 필요해요.

325
00:43:29,000 --> 00:43:37,000
이 벡터들은 R³ 안에 있는 거니까, 우리가 만들 벡터 공간도 R³ 안에 있어요.

326
00:43:37,000 --> 00:43:42,000
핵심은 — 이 벡터들로부터 선형결합을 만들 수 있어야 한다는 거예요.

327
00:43:42,000 --> 00:43:50,000
자, 기하적으로 생각해봅시다. 벡터 (1,2,4)를 그리면 아마 이쯤일 거고,

328
00:43:50,000 --> 00:43:57,000
벡터 (3,3,1)은 — 어딘지는 모르겠지만 이쯤이라고 해봅시다.

329
00:43:57,000 --> 00:44:06,000
그게 첫 번째 열, 두 번째 열이에요.

330
00:44:06,000 --> 00:44:13,000
그럼 전체 열공간은 뭐죠?

331
00:44:13,000 --> 00:44:19,000
이 두 벡터의 모든 선형결합을 생각하는 겁니다.

332
00:44:19,000 --> 00:44:24,000
전체 공간을 얻을까요? 아니면 평면일까요?

333
00:44:24,000 --> 00:44:31,000
직선보다는 많고, 0 벡터보다는 많지만, 0 벡터도 포함돼 있어요.

334
00:44:31,000 --> 00:44:39,000
두 벡터의 선형결합을 모두 취하면 R³ 전체가 되진 않겠죠.

335
00:44:39,000 --> 00:44:46,000
그럼 무엇이 될까요?

336
00:44:46,000 --> 00:44:52,000
하나의 직선도 채워지고, 다른 직선도 채워지고, 그 사이의 모든 벡터들도 채워집니다.

337
00:44:52,000 --> 00:44:58,000
왜냐하면 한쪽에서 나온 벡터, 다른 쪽에서 나온 벡터를 더할 수 있으니까요.

338
00:44:58,000 --> 00:45:05,000
결국 평면이 나오는 거예요.

339
00:45:05,000 --> 00:45:10,000
그리고 그건 원점을 지나는 평면입니다.

340
00:45:10,000 --> 00:45:17,000
이 두 벡터, (1,2,4)와 (3,3,1)을 가지고

341
00:45:17,000 --> 00:45:25,000
모든 선형결합을 만들면 하나의 평면을 채우게 돼요. 꼭 생각해 보세요.

342
00:45:25,000 --> 00:45:31,000
이 그림을 머릿속에 그릴 수 있어야 해요. R³에서는 그게 가능하죠. 왜냐하면

343
00:45:31,000 --> 00:45:40,000
곧 R¹⁰에서도 이걸 해야 하거든요. 예를 들어, R¹⁰에서 벡터 5개를 조합한다고 하면

344
00:45:40,000 --> 00:45:46,000
그 결과는 뭘까요? 신만 알겠죠. 어쨌든 부분공간 하나가 나옵니다.

345
00:45:46,000 --> 00:45:52,000
그 벡터들은 전부 성분이 10개고, 우리는 그 선형결합을 생각하는 거예요.

346
00:45:52,000 --> 00:45:58,000
R⁵는 아니에요. 왜냐하면 벡터들의 성분 수가 10개니까요.

347
00:45:58,000 --> 00:46:05,000
대신, 원점을 지나는 5차원의 평면(flat) 같은 게 나올 수도 있어요.

348
00:46:05,000 --> 00:46:12,000
물론 그 5개 벡터가 모두 같은 직선 위에 있다면, 우리가 얻는 건 그 직선 하나뿐이에요.

349
00:46:12,000 --> 00:46:21,000
이처럼 가능성은 다양해요. 결국은 벡터들이 어떤 형태이냐에 달렸어요.

350
00:46:21,000 --> 00:46:28,000
방금도 열 두 개가 같은 직선 위에 있었다면, 열공간도 직선이 됐겠죠.

351
00:46:28,000 --> 00:46:35,000
하지만 여기선 평면이 됐어요. 좋아요.

352
00:46:35,000 --> 00:46:44,000
여기서 오늘은 마무리할게요. 이게 핵심 개념입니다 — 행렬로부터 부분공간을 만드는 훌륭한 예제예요.

353
00:46:44,000 --> 00:46:51,000
행렬의 열을 가져오고, 그 선형결합을 모두 취하면

354
00:46:51,000 --> 00:46:57,000
그게 바로 열공간입니다.

355
00:46:57,000 --> 00:47:04,000
그리고 이건 선형대수를 더 높은 관점에서 보는 출발점이죠.

356
00:47:04,000 --> 00:47:10,000
다음 강의에서는 A와 Ax=b를 다시 살펴볼 거예요.

357
00:47:10,000 --> 00:47:22,000
이 새로운 언어 — 벡터공간과 열공간의 언어로 Ax=b를 어떻게 이해할 수 있을지 말이죠.

358
00:47:22,000 --> 00:47:30,000
그리고 다른 부분공간들도 있어요. 열공간이 가장 대표적인 것이고, 나머지는 이후에 다룰 거예요.

359
00:47:30,000 --> 00:47:33,000
좋습니다. 감사합니다.

