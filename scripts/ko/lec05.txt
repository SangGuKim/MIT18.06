0:00
좋아요. 이번 강의는 선형대수학(Linear Algebra) 제5강입니다.  
이번 강의로 이 장이 마무리돼요.

0:19
이 장의 마지막 절은  
2.7인데요, 여기서 순열(Permutations)을 다루고,

0:24
그건 지난 강의의 마지막에서 설명했죠.  
그리고 전치(Transposes)도 지난 시간에 나왔어요.

0:36
이 둘에 대해서 조금 더 다룰 게 있어요 —  
순열과 전치 말이죠.

0:42
그런데 오늘 강의의 핵심은,  
어떻게 보면 선형대수학의 진짜 시작점이라고 할 수 있는 부분이에요.

0:48
벡터 자체를 넘어서,  
벡터공간(Vector Spaces), 그리고 그 부분공간(Subspaces)을 보는  
더 넓은 시야를 갖는 부분이죠.

1:06
우리는 지금 강의 진도보다 약간 앞서 있어요.  
좋은 일이죠, 왜냐하면 이제부터 할 일이 많아지니까요.

1:13
자, 그럼 순열부터 시작해봅시다.

1:22
이 순열은요, P 행렬들이고,  
행 교환(Row Exchanges)을 수행하는 행렬들이에요.

1:36
그리고 우리는 이런 행렬들이 필요할 수 있어요.  
A라는 아주 좋은 행렬이 있다고 할게요 — 역행렬도 존재하고,  
Ax = b를 풀 수 있죠.

1:52
그런데 그걸 풀기 위해서 —  
우리는 이런 자유도가 있어야 해요.

2:00
피벗(pivot) 자리에 0이 나타나면,  
그걸 다른 행과 바꿔서 0이 아닌 수로 바꿔줘야 하죠.

2:05
그래야 올바른 피벗을 갖게 되니까요.

2:12
여러분은 이런 과정을 이미 본 적이 있을 거예요.  
지금은 이 아이디어들을 정리하고자 해요.

2:18
원칙적으로는, 두 번 이상의 행 교환이 필요할 수도 있어요.

2:24
그러니까 이 이론을 완성하려면,  
A 행렬을 받아서 소거를 시작했는데  
중간에 행을 교환해야 했고,  
그걸 하고 나서 마무리했다는 가능성을 포함해야 해요.

2:41
좋아요. 제가 지금 말하고 싶은 건 —  
이걸 아주 깊게 다루진 않겠지만 —

2:49
A = LU라는 식이 있을 때,  
행 교환이 들어오면 어떻게 되는가예요.

2:54
A = LU는 —

2:59
L은 대각선에 1이 있고, 그 위는 0이고,  
그 아래는 곱셈 계수들이 있는 행렬이었죠.

3:05
U는 아래쪽이 0인 상삼각 행렬이고요.

3:13
이건 오직 특정한 경우에만 가능한 형태예요.

3:19
즉, 소거 과정을 이렇게 묘사하는 건  
P, 즉 행 교환이 없을 때만 해당돼요.

3:26
이제 저는 "행 교환이 있을 때는 어떻게 하지?" 라는 걸 말하고 싶은 거예요.

3:33
A = LU라는 식에서, P가 항등행렬(identity matrix)이었던 경우죠.

3:40
행의 순서가 이미 좋았기 때문에 그대로 놔뒀던 거예요.  
여기서 현실적인 예를 하나 덧붙이자면요,

3:47
Matlab은 소거를 할 때, 단지 피벗이 0이 아니냐만 체크하는 게 아니에요.

3:55
Matlab은 피벗이 충분히 "큰 수"인지도 봐요.  
작은 피벗은 싫어하죠. 수치적으로 불안정하거든요.

4:09
0에 가까운 피벗은 수치적으로 문제가 돼요.  
그래서 Matlab은 Ax = b를 풀라고 하면,

4:16
필요 없다고 생각되는 경우에도  
행 교환을 몇 번 하게 돼요.

4:23
수학적으로는 안 해도 되지만,  
수치적 정확도를 위해선 필요하죠.

4:31
우리는 수학적인 관점에서 보고 있으니까,  
정말 필요할 때만 행 교환을 하도록 해요.  
하지만 필요할 수도 있어요.

4:45
그리고 그 결과가 바로 여기 숨겨져 있어요.  
이게 핵심이에요.

4:56
행 교환을 포함한 소거 과정의 묘사는 이렇게 됩니다:  
A = LU가 아니라, PA = LU.

5:12
여기서 P는 행을 교환해주는 행렬이에요.  
실제로 행들을 올바른 순서로 정렬해줘요.

5:18
즉, 피벗 자리에 0이 나타나지 않도록 해주죠.  
그래서 L과 U가 위에 나왔던 것처럼 잘 나오게 돼요.

5:32
이게 핵심이에요. 사실 이걸 길게 설명하고 싶진 않아요.

5:39
Permutation Matrix — 순열 행렬에 대해 얘기해볼게요.  
여러분은 지난 시간에 배웠을 거예요.

5:47
순열 행렬의 주요 특성들을 다시 상기시키고,

5:57
그리고 이 분해(PA = LU)를 일반적인 형태로 남겨둘게요.

6:03
모든 가역행렬 A에 대해 이게 성립해요.

6:17
거의 대부분의 경우엔 P가 필요 없어요.  
하지만 일부 경우엔 행 교환이 필요하고,  
그럴 땐 이렇게 처리하는 거예요.

6:30
자, 마지막으로 P가 뭔지 다시 떠올려 봐요.

6:46
순열 P는, 항등행렬에서  
행의 순서만 바꾼 형태예요.

6:56
그냥 그대로 두는 경우도 포함되죠.  
즉, 항등행렬도 하나의 순열이에요.

7:02
그건 가장 기본적인 순열 행렬이에요 —  
아무 일도 안 하는 순열이죠.

7:08
그리고 두 개의 행을 바꾸는 행렬,  
세 개, 네 개의 행을 바꾸는 행렬도 있어요.

7:21
만약 4개의 행이 있다면,  
그걸 한 바퀴 돌리는 순환 순열도 있을 수 있어요.  
1→2, 2→3, 3→4, 4→1처럼요.

7:35
혹은 1과 2, 3과 4를 각각 바꾸는 식도 있겠죠.

7:41
굉장히 다양한 경우의 수가 생겨요.  
그럼 그 수는 얼마나 될까요?

7:46
정답은 팩토리얼(factorial)이에요.  
n × (n-1) × (n-2) × ... × 1.

7:56
이건 가능한 재배열의 수를 의미해요.

8:05
즉, n × n 순열 행렬의 개수예요.

8:15
그리고 이런 행렬들은 모두,  
다시 원래 순서로 되돌릴 수 있기 때문에  
역행렬이 존재해요.

8:32
행을 다시 제자리로 돌리는 행렬이 있으니까요.  
그게 바로 P의 전치(transpose)예요.

8:46
P에 전치를 곱해보면,  
1들이 서로 맞아 떨어져서  
항등행렬이 나오게 돼요.

8:57
우리는 이런 성질이 좋은 행렬들에 관심이 많을 거예요.

9:02
이를 다른 말로 표현하면,  
Pᵀ × P = I 라는 식이죠.

9:09
이건 곧, 전치가 역행렬이라는 걸 의미해요.

9:25
우리는 이런 행렬에 관심이 있어요.  
단지 순열뿐만 아니라, 다른 경우도 포함되지만  
지금 중요한 건, 순열 행렬이  
그런 특수 행렬들의 중심에 있다는 거예요.

9:42
자, 이제 우리는 그 개수도 알아요.

9:47
4×4 순열은 총 24개였죠.  
5!은 120이니까,  
5×24 = 120이 되겠네요.  
5×5 순열을 전부 나열하는 건 별로 재미 없을 거예요.

10:09
좋아요, 여기까지가 순열이에요.

10:15
그리고 이제 2.7절에는  
전치(transpose)에 대한 설명도 들어 있어요.

10:20
그걸 이제 마무리해볼게요. 우선, 아직 칠판에 전치된 행렬을 안 써봤네요?

10:30
한 번 써봐야겠어요. 예를 들어  
(1 2 4; 3 3 1) 같은 행렬이 있다고 해봅시다.

10:39
직사각형 행렬이죠. 3행 2열이에요.

10:47
이걸 전치하면 어떻게 될까요?

10:53
전치 기호로 T를 쓰겠습니다. Matlab에서는 ' (프라임)을 써요.

10:59
결과는 — 여기 써볼게요.  
원래는 3행 2열이었는데,

11:07
전치하면 2행 3열이 되죠.

11:13
즉, 더 짧고 더 넓어진 형태예요.

11:20
물론, 열(column)은 행(row)이 되고 —

11:25
각 열이 행으로 바뀌어요. 동시에,  
행도 열로 바뀌어요.

11:36
이 행도 열이 된 거죠.  
자, 그럼 일반적인 전치 공식은 뭘까요?

11:41
전치는 —

11:48
지금 숫자로 본 걸 기호로 표현하면 똑같은 거예요.

11:54
물론 숫자로 보는 게 가장 직관적이지만,  
기호로도 써볼게요.

12:04
A의 전치에서, i행 j열의 값은 뭐가 될까요?

12:10  
그 값은 A에서 나온 거예요.

12:16  
주대각선(main diagonal)을 기준으로 뒤집어서 나온 거죠.

12:22  
그리고 실제로, 그건 A의 원소 중  
J행 I열에 있던 값이에요.

12:28  
그래서 행과 열의 인덱스가 서로 바뀐다는 거예요.

12:34  
행 번호가 열 번호가 되고, 열 번호가 행 번호가 되는 거죠. 문제없어요.

12:45  
좋아요. 이제 특별한 — 가장 좋은 행렬들을 볼게요.

12:52  
많은 응용 분야에서, 대칭 행렬(symmetric matrix)이 나타나요.

12:58  
그래서 대칭 행렬에 주목해 볼게요.

13:07  
'symmetric'라는 말은 무슨 뜻일까요?  
이 말은, 전치(transpose)해도 행렬이 바뀌지 않는다는 뜻이에요.

13:16  
A의 전치가 A와 같다는 거죠.

13:21  
예제를 하나 들어보죠. 대칭인 행렬을 생각해 볼게요.

13:29  
대각선 위에 어떤 값이든 괜찮아요 — 하지만  
대각선 위쪽에 있는 값이, 아래쪽에도 있어야 해요.  
예를 들어 1이 위에 있으면, 그 아래도 1, 7이 있으면 아래도 7, 9도 마찬가지죠.

13:43  
이런 게 대칭 행렬이에요.  
전 숫자를 모두 양수로 썼지만,

13:52  
그게 핵심은 아니에요. 핵심은, 전치를 해도  
똑같은 행렬이 다시 나온다는 거예요.

13:58  
즉, Aᵀ = A. 이게 대칭 행렬의 특징이에요.  
여기서 제가 말씀드리고 싶은 건,

14:07  
전치해도 바뀌지 않는  
행렬들의 집합이 있다는 거예요.

14:14  
그리고 이건 쉽게 알아볼 수 있어요.

14:22  
예전엔 전치가 역행렬이 되는 경우도 봤죠.  
그건 중요하지만, 이해하기 쉬운 건 아니에요.

14:36  
지금의 경우처럼, 전치해도 그대로 나오는 경우는  
확실히 쉽게 볼 수 있어요.

14:42  
좋아요. 그럼 이런 행렬이 어떻게 생길 수 있는지 볼까요?

14:49  
예를 들어, 아까 본 저 행렬은  
절대 대칭이 아니었죠.

14:55  
전치해도 모양 자체가 다르잖아요 —  
직사각형이니까, 전치하면 눕게 되죠.

15:06  
하지만 이걸 대칭 행렬로 바꿀 수 있는 방법이 있어요.

15:11  
곱해보세요.  
이 직사각형 행렬 — 이름을 R이라고 할게요. (rectangular)

15:17  
그럼 Rᵀ은 그 전치(transpose)겠죠.  
이 둘을 곱하면,

15:22  
대칭 행렬이 나올 거예요.

15:32  
이걸 숫자로 계산해보면 대칭이 되는 걸 볼 수 있고,  
왜 그런지도 생각해볼 수 있어요.

15:44  
중요한 건, RᵀR은 항상 대칭이라는 거예요.

15:52  
좋아요?

15:57  
지금 계산해보려는 건  
지금 우리가 만든 이 RᵀR이에요.

16:02  
Rᵀ의 열은 1 2 4, 그리고 3 3 1 이었죠.

16:09  
제가 그걸 Rᵀ이라 불렀고,  
다른 건 R이라고 했어요. 맞죠?

16:16  
그럼 계산해봅시다. 위쪽 원소는 10이 나와요.

16:22  
그 옆은 2, 9, 다음은 11,  
그 다음은 4, 3, 7이 나와요.

16:30  
그 11은 1×3 + 3×3에서 나온 거죠?  
1행 2열에서요.

16:37  
그럼 반대쪽은요? 2행 1열에서 나온 값은?

16:43  
결과는 똑같죠.  
1×3 + 3×3이니까요.  
순서만 바뀐 거예요.

16:50  
결과는 11이에요.  
이게 바로 대칭성(symmetric)의 핵심이죠.

16:56  
이제 나머지도 채워볼 수 있어요.

17:02  
그 7도 아래쪽에 반복되죠.  
그 외에 4개의 숫자만 더 있으면 돼요.

17:10  
1×4 + 3×1에서 나온 7은  
4×1 + 1×3으로도 다시 나오죠.

17:16  
이게 잘 작동하는 걸 알 수 있죠?

17:24  
이걸 기호로도 볼 수 있어요.  
행렬 언어로 표현하면요.

17:29  
그 7은 우연히 나온 게 아니에요.

17:35  
11도 마찬가지예요.

17:40  
그럼 이걸 전치했을 때  
대칭인지 어떻게 알 수 있을까요?

17:49  
전치해봤을 때,  
그 결과가 원래 행렬과 같다면 대칭이죠.

17:54  
그럼 RᵀR을 전치해보죠.

17:59  
왜 그런 결과가 나오는지를 볼 수 있어요.

18:09  
이게 대칭임을 보이는 유일한 방법은  
전치를 해보고 바뀌었는지를 확인하는 거예요.

18:19  
좋아요, 그럼 RᵀR의 전치를 해봅시다.

18:27  
이건 전치 규칙(transpose rule) 연습이에요.

18:33  
규칙은, 곱의 전치는  
순서를 바꿔서 각각 전치하는 거예요.

18:44  
즉, 전치된 순서로 두 행렬이 나와요.

18:51  
첫 번째는 뒤쪽 행렬을 전치한 것이고,

18:56  
두 번째는 앞쪽 행렬을 전치한 것이죠.

19:03  
그럼 여기서 Rᵀᵀ은 뭘까요?

19:15  
다 같이 말하지는 마세요. Rᵀᵀ은  
한 번 뒤집고, 또 한 번 뒤집은 거죠.

19:22  
결국 원래대로 돌아오니까 R이죠.

19:28  
이게 핵심이에요.  
시작한 행렬을 전치하고 또 전치하면  
원래 행렬이 나오는 거예요.

19:34  
그래서 숫자 없이도 확인이 되죠.

19:46  
두 줄짜리 계산으로  
항상 대칭 행렬이 나온다는 걸 보여줬어요.

19:52  
그리고 실제로 많은 응용에서  
이런 방식으로 대칭 행렬이 생겨나요.

20:00  
좋아요. 오늘 저는 순열(Permutation),  
전치(Transpose), 대칭성(Symmetry)에 대해 설명했고,

20:07  
이제 3장을 시작할 준비가 됐어요.  
잠깐 숨 돌릴까요 —

20:21  
녹화 테이프는 쉬지 않지만  
강사는 좀 쉬어야겠네요. 왜냐하면 이제  
벡터공간(Vector Spaces)을 설명해야 하니까요.

20:31  
자, 이제 집중해 주세요.

20:38  
벡터공간이란 무엇인가요?

20:47  
그리고 부분공간(Subspaces)은 뭘까요?  
우리가 주로 하는 연산은 뭐죠?

21:01  
벡터로 뭘 하죠? 더해요.  
벡터끼리 더하는 걸 알고 있죠.

21:07  
또 숫자를 곱해요. 보통 스칼라(Scalar)라고 하죠.

21:13  
벡터 V가 있으면, 3V가 뭔지 알고 있어요.  
벡터 V와 W가 있으면, V + W가 뭔지도 알아요.

21:24  
이 두 가지 연산이 기본이에요.

21:29  
어떤 집합이 벡터공간이라고 말하려면  
이 연산들을 할 수 있어야 해요.

21:35  
즉, 덧셈과 스칼라 곱이 가능해야 하고,  
어떤 기본적인 규칙들을 만족해야 해요.

21:44  
좋아요. 그럼 예시부터 시작해 볼게요.  
이제 벡터공간에 대해 이야기합니다.

21:50  
22:06  
먼저, '공간(space)'이라는 말이 무슨 뜻인지 다시 말할게요.  
'공간'이란 말은 저에게

22:14  
벡터들이 모인 어떤 집합을 의미해요 —  
그냥 아무 벡터 집합이 아니라,

22:19  
벡터공간이라는 말은  
벡터에 적합한 연산이 가능한 공간이어야 해요.

22:28  
벡터끼리 더할 수 있어야 하고,  
숫자를 곱할 수 있어야 하죠.

22:37  
선형 결합(linear combination)을 만들 수 있어야 해요.  
그런 건 어디서 봤죠?

22:43  
우리는 R²에서 그런 걸 봤어요.

22:48  
그럼 그게 어떤 벡터공간인지 봅시다.

22:54  
R²는 실수(real number) 두 개를 의미해요.

22:59  
즉, 두 실수로 이루어진 벡터들이라는 뜻이에요.

23:11  
예를 들어 이런 벡터들 —  
|3; 2|, |0; 0|, |π; e| 등등이죠.

23:30  
이런 식으로요.

23:35  
그리고 이건 아주 자연스러운 거예요.  
이제 대수부터 봅시다.

23:44  
대수라는 건, 이런 벡터들에  
무슨 연산을 할 수 있느냐예요. 더할 수 있어요.

23:50  
이 벡터와 저 벡터를 더할 수 있어요.

23:58  
어떻게 더하죠? 각 성분별로 더하죠.  
(3,2) + (0,0)은 (3,2).

23:58  
(3,2) + (π,e)는 (3+π, 2+e)가 되죠.

24:05  
아, 이게 뭘 하는지 아시죠. 그리고 이 벡터에 대한 그림도 떠오를 거예요.

24:11  
여기 벡터 (3,2)가 있어요. 그림에는 보통 화살표가 그려지죠.

24:19  
그리고 벡터 (0,0)는 굉장히 중요한 벡터예요 — 아마 가장 중요한 벡터일 거예요.

24:24  
그 자리에 있어야 하고, 당연히 화살표는 거의 없겠죠.

24:29  
π는... 기억해야겠네요 — π는 대략 3보다 약간 크고,

24:35  
e는 대략 2보다 약간 크죠. 그러니까 아마 (π,e)는 이쯤일 거예요.

24:41  
π와 e 벡터는 제가 그려본 적 없네요.  
하지만 아주 자연스러워요.

24:47  
첫 번째 성분은 수평 방향이고,

24:55  
두 번째 성분은 수직으로 올라가는 방향이에요.

25:02  
좋아요. 전체 평면이 R²입니다.

25:07  
그러니까 R²는, 말하자면, 평면이에요.

25:14  
xy 평면이죠. 다들 그렇게 생각하죠.

25:24  
하지만 핵심은, 이건 벡터공간이라는 거예요.  
왜냐하면 모든 벡터들이 그 안에 들어 있으니까요.

25:32  
그 중 하나를 빼버리면 — 예를 들어 (0,0)을 뺀다고 해봅시다.

25:39  
xy 평면에서 점 하나를 뺀, 구멍 난 평면을 생각해 보세요.

25:46  
즉, 원점을 뺀다면요. 그건 끔찍한 일이에요. 왜일까요?

25:52  
왜 원점이 꼭 있어야 할까요?  
왜냐하면 다른 벡터들이 있다면,

25:59  
예를 들어 이 (3,2) 벡터가 있다면 —  
이걸 어떤 수로든 곱할 수 있어야 하니까요. 0도 포함해서요.

26:05  
0으로 곱하는 것도 가능해야 하고,  
결과 벡터도 그 공간 안에 있어야 해요.

26:12  
그 점이 없으면 안 돼요.

26:18  
그리고 (3,2)와 그 반대인 (-3,-2)를 더했을 때,

26:23  
다시 원점으로 돌아가야 해요.

26:29  
원점 없이 벡터공간은 성립하지 않아요.  
모든 벡터공간에는 0 벡터가 있어야 해요.

26:36  
좋아요, 이건 쉬운 예제예요. 그림으로 쉽게 이해할 수 있는 벡터공간이죠.

26:42  
R³도 마찬가지로 쉽습니다.

26:50  
위로 좀 올라가볼게요. 이건 —  
R³는 3차원 벡터 전체를 말해요.  
또는 세 개의 실수 성분을 가진 벡터들이죠.

27:09  
좋아요.

27:15  
우리가 같은 얘기를 하고 있는지 확실히 하려고,

27:21  
(3,2,0) 벡터를 한번 봅시다.

27:29  
이건 R²에 속하나요, R³에 속하나요?  
명백하게 R³에 속하죠.

27:38  
성분이 3개예요. 하나가 0이긴 해도 괜찮아요.  
0도 실수니까요.

27:43  
그래서 이건 R³에 속하는 벡터예요.  
혼동하면 안 돼요.

27:51  
벡터를 정확히 구분해야 하고, Rⁿ도 정확히 알아야 해요.  
그럼 Rⁿ은 뭘까요?

27:57  
Rⁿ — 이건 아주 중요한 예제예요.  
성분이 n개인 모든 벡터들을 말해요.

28:05  
그리고 전부 열 벡터(column vector)로 쓰고 있어요.

28:11  
그 규칙을 따르겠습니다.  
열 벡터로 쓰고, 성분들은 실수입니다.

28:17  
나중엔 복소수와 복소 벡터도 다루겠지만,  
그건 훨씬 나중 일이에요.

28:24  
좋아요. 이건 벡터공간이에요.

28:31  
이제 벡터공간에 대해 뭘 말씀드려야 할까요?  
제가 가장 중요한 말은 했어요 —  
R²의 어떤 두 벡터를 더해도 여전히 R²에 있고,

28:44  
어떤 수를 곱해도 여전히 R²에 있어요.

28:50  
어떤 조합을 만들어도 R²에 있어요. Rⁿ도 마찬가지예요.

28:55  
그리고 이제 솔직히 말씀드려야겠죠.  
이러한 덧셈과 곱셈 연산은

29:02  
몇 가지 규칙을 따라야 해요.

29:08  
예를 들어, 우리가 임의로  
(3,2) + (π,e) = (0,0)이라고 하면 안 돼요.

29:15  
그건 아니에요. (3,2) + (-3,-2)가 (0,0)인 건 맞지만요.

29:22  
사실 책에는 덧셈과 곱셈이 따라야 할  
8가지 규칙이 나와 있어요.

29:32  
하지만 Rⁿ에서는 그 규칙들을 다 만족해요.  
보통 문제는 그 8가지 규칙이 아니에요.

29:38  
문제는, 덧셈이나 곱셈을 했을 때  
그 공간 안에 여전히 있는지예요.

29:50  
그게 안 되는 예를 하나 보여드릴게요.

29:55  
그래서 이건 벡터공간이 **아닌** 경우가 됩니다.

30:05  
xy 평면, 즉 R²는 벡터공간이에요.

30:11  
그런데 이제 그 일부만 가져올게요.  
예를 들어 이 부분만요.

30:17  
벡터 성분이 둘 다 0 이상인  
1사분면 부분만 취한다고 해봅시다.

30:24  
그럼 이런 경우엔 덧셈은 안전할까요?

30:37  
예, 덧셈은 괜찮아요.  
(3,2)와 (5,6)을 더하면  
여전히 1사분면에 있어요.

30:45  
덧셈은 문제없어요.  
하지만 스칼라 곱에서는 큰 문제가 생깁니다.

30:54  
왜냐하면 음수를 곱하면  
그 공간을 벗어나기 때문이죠.

31:02  
(3,2)에 -5를 곱하면  
저 아래쪽 어딘가로 가버려요.

31:08  
그래서 이건 벡터공간이 아니에요.  
왜냐하면 닫힘(closed) 조건을 만족하지 않기 때문이죠.

31:14  
실수 전체에 대해 곱셈이 닫혀 있지 않아요.

31:19  
즉, 벡터공간은  
벡터의 덧셈과 곱셈에 대해 닫혀 있어야 해요.

31:27  
다시 말해, 선형결합(linear combination)이 가능해야 해요.  
그러니까, 몇 개의 벡터를 주면 —

31:37  
이제 정말 중요한 예로 갑니다.  
Rⁿ이야말로 가장 중요한 벡터공간이죠.

31:47  
그런데 우리는 Rⁿ 내부의  
**부분 벡터공간**에도 관심을 가져요.

31:52  
규칙은 따르지만,  
Rⁿ 전체가 아니라 그 안의 일부인 거죠.

32:01  
아까 R²에서 시작해서,

32:10  
그 중 일부만 가져왔더니  
벡터공간이 아니게 됐어요.

32:17  
그럼 이번엔 R²의 일부면서도  
**진짜 벡터공간**인 경우를 보여드릴게요.

32:25  
그 공간 안에서 덧셈과 곱셈을 해도  
여전히 그 공간 안에 머무는 경우요.

32:31  
그걸 우리는 부분공간(subspace)이라고 부릅니다.  
앞서 말한 나쁜 예제를 이제 좋은 예제로 바꿔볼게요.

32:40  
R²에서 다시 시작해서,  
이번에는 진짜 벡터공간인 예제를 봅시다.

32:50  
그러면 이건 R² 내부의 벡터공간이 될 거예요.

32:56  
그래서 우리는 그걸 R²의 부분공간이라고 부릅니다.

33:03  
좋아요. 뭘 할 수 있을까요?

33:09  
무언가 벡터 하나는 들어 있어야 해요.  
예를 들어 이 벡터가 있다고 해봅시다.

33:14  
이 벡터가 내 부분공간에 포함돼 있다면,

33:19  
진짜 부분공간이라면  
그와 관련된 다른 벡터들도 있어야 하겠죠?

33:24  
예를 들어 그걸 2배한 벡터도 있어야 하고,

33:33  
0배, 1/2배, 3/4배도 있어야 해요.

33:39  
-1/2배, -1배도 있어야 해요.

33:44  
모든 실수에 대해 곱해진 벡터가 있어야 해요.  
즉, 그 벡터가 포함되어 있다면  
그 벡터가 놓인 **직선 전체**가 있어야 해요.

33:52  
무슨 말인지 아시겠죠?  
벡터 하나가 있으면

33:58  
그걸 포함하는 직선 전체가 있어야 해요.  
그 선형 결합까지 포함되지 않으면  
벡터공간이 안 돼요.

34:09  
이제 덧셈 조건도 확인해야겠죠.

34:15  
하지만 이 직선이라면 괜찮아요.  
직선 위의 벡터끼리 더하면  
여전히 직선 위에 있어요.

34:26  
예제입니다. 이건 부분공간의 예제예요 —  
우리 예제는 R² 안의 직선이에요.  
단, 아무 직선이 아니에요.

34:45  
이런 직선을 생각해보죠.  
이 직선 위의 모든 벡터들 —  
예: 이 벡터, 저 벡터, 또 다른 벡터들.

34:56  
제가 지금 연하게 그리고 있는 건  
**부분공간이 아닌** 예제예요.

35:05  
왜냐하면 R² 안에서  
**부분공간이 되려면** 그 직선은 반드시 원점을 지나야 해요.

35:15  
왜 이 직선은 안 될까요?

35:21  
점선(dashed line)으로 표시해볼게요.

35:27  
이 점선 위의 어떤 벡터에  
0을 곱하면, 이 아래로 내려오게 돼요.  
점선 위에 있지 않게 되죠.

35:34  
그러니까 0 벡터는 반드시 있어야 해요.  
모든 부분공간에는 0 벡터가 반드시 있어야 해요.

35:39  
왜냐하면 어떤 벡터든 0을 곱했을 때  
항상 0 벡터가 되기 때문이죠.

35:46  
좋아요. 이제 부분공간을 몇 개 만들어 보려 해요.

35:51  
R² 안에 있는 동안, 가능한 모든 경우를 한번 생각해보죠.

35:59  
R²에서는 경우가 그리 많지 않아요. 그럼 가능한 부분공간들은 뭐가 있을까요?

36:07  
지금부터 R²의 부분공간들을 나열해볼게요.

36:16  
첫 번째로 항상 가능한 경우는 —

36:23  
R² 전체, 전체 공간입니다.

36:29  
전체 공간도 자기 자신에 대한 부분공간으로 인정돼요. 항상 포함시켜야 해요.

36:35  
그리고 나머지들은 직선입니다 —  
무한히 양쪽으로 뻗은 직선, 단, 원점을 지나야 해요.

36:45  
그건 마치 전체 공간과도 비슷하고 —  
이건 2차원 전체 공간이죠.

37:00  
이건 일차원이라고 볼 수 있어요.  
이 직선이 R¹과 같을까요? 아니요.

37:07  
겉보기엔 R¹과 매우 비슷해요. R¹도 직선이고, 이것도 직선이니까요.

37:14  
하지만 이건 R² 안의 직선이에요. 벡터들이 성분 두 개를 가지고 있어요.

37:20  
그래서 R¹과는 달라요. R¹에서는 벡터가 성분 하나만 가집니다.

37:25  
아주 비슷하긴 하지만, 같지는 않아요.  
좋아요, 이제 세 번째 경우가 있어요.

37:32  
R²의 세 번째 부분공간은 —

37:40  
전체 공간도 아니고, 직선도 아니에요.

37:47  
더 작은 거예요. 바로 0 벡터 하나만 있는 경우예요.

37:55  
38:01  
전 이 부분공간을 Z라고 부르기도 해요. Zero에서 따온 이름이죠.  
직선은 L, 전체 평면은 R²라고 부를게요.

38:07  
자, 이제 0 벡터 하나만 있는 것도 괜찮은가를 봐야 해요.

38:14  
부분공간의 의미를 이해하려면 규칙을 알아야 하고 —  
규칙을 안다는 건 곧 이런 것도 확인해야 해요.

38:20  
0 벡터 하나만 있는 경우도 규칙을 만족하는가?

38:27  
왜 그럴까요? 너무 당연해서 설명하기가 민망할 정도예요.  
이걸 자기 자신과 더하면 그대로예요.

38:36  
17을 곱해도 여전히 그대로예요.  
즉, 필요한 연산 — 덧셈, 스칼라 곱을 해도 여전히 그 공간 안에 있어요.

38:44  
어떤 연산을 해도 이 한 점을 벗어나지 않아요.

38:50  
그래서 이건 항상 유효한 가장 작은 부분공간이에요.

38:57  
가장 큰 부분공간은 전체 공간이고, 그 사이엔 —

39:02  
뭐든지 중간에 올 수 있겠죠.

39:07  
예를 들어, R³에서는 어떤 경우가 있을까요?

39:18  
3차원 공간에서는 한쪽 끝이 전체 공간 R³이고,  
다른 쪽 끝은 0 벡터 하나예요.

39:23  
그 중간은? 원점을 지나는 평면이 하나 있고,

39:32  
또 원점을 지나는 직선도 있어요.  
결국 R³에서는 네 가지가 가능한 거예요:  
전체 공간, 평면, 직선, 그리고 0 벡터 하나.

39:43  
좋아요. 이제 개념은 잡히셨죠.  
이제 진짜 중요한 질문은 —

39:51  
실제로 이런 부분공간들이 어디서 오는가?  
행렬과 어떻게 연결되는가?

39:57  
그걸 이야기하려고 해요. 자, 이 행렬을 가져와 봅시다.

40:06  
그 행렬로부터 부분공간을 만들어보려고 해요.

40:17  
그 중 하나는 **열(column)들로부터 나오는** 부분공간이에요.

40:26  
이게 바로 중요한 부분공간입니다.

40:34  
행렬로부터 나오는 첫 번째 중요한 부분공간이죠 —  
이 행렬을 다시 A라고 부를게요.

40:40  
A의 열들을 보는 겁니다.

40:48  
이 열들은 R³에 속해 있어요.  
R³ 안에 있는 벡터들이죠.

40:58  
그 열들이 내 부분공간 안에 있기를 원해요.

41:04  
하지만 열 두 개만 넣고 "부분공간이다"라고 말할 수는 없어요.

41:11  
그 열들을 포함하고 싶다면, 무엇까지 포함시켜야 할까요?

41:16  
덧셈이 가능해야 해요.  
두 열을 더한 것도 있어야 해요.

41:25  
두 열의 합 — 예를 들어 (4,5,5) 같은 벡터도 포함돼야 해요.

41:34  
그리고 첫 번째 열에 세 번째 열을 세 배 곱해서 더한 벡터도 있어야 해요.

41:42  
0 벡터도 반드시 있어야 하고요.

41:48  
즉, 모든 선형결합이 포함돼야 해요.

41:54  
그래야 진짜 부분공간이 됩니다.

42:02  
다시 말해, 이 열들은 R³에 있는 벡터들이고,  
그들의 모든 선형결합이 **하나의 부분공간**을 이룹니다.

42:14  
선형결합이란 건 뭐냐면,  
하나에 어떤 수를 곱하고, 다른 것에도 어떤 수를 곱하고,  
그걸 더하는 거예요.

42:28  
선형대수에서의 두 가지 연산 —  
스칼라 곱과 벡터 덧셈이죠.

42:33  
이 모든 연산 결과들을 포함시키면  
그건 자동으로 부분공간이 돼요.

42:46  
그리고 우리는 거기에 이름을 붙일 거예요 —  
바로 **열공간(column space)** 입니다.

42:53  
열공간.

43:01  
기호로는 C(A)라고 씁니다.  
C는 column의 첫 글자예요.

43:07  
여기에 중요한 개념이 숨어 있어요 —

43:15  
오늘 강의의 중심 개념은 이거예요:

43:22  
벡터 몇 개만으로는 만족하지 않아요.  
우리는 벡터의 **공간**이 필요해요.

43:29  
이 벡터들은 R³ 안에 있는 거니까,  
우리가 만들 벡터 공간도 R³ 안에 있어요.

43:37  
핵심은 — 이 벡터들로부터  
선형결합을 만들 수 있어야 한다는 거예요.

43:42  
자, 기하적으로 생각해봅시다.  
벡터 (1,2,4)를 그리면 아마 이쯤일 거고,

43:50  
벡터 (3,3,1)은 — 어딘지는 모르겠지만 이쯤이라고 해봅시다.

43:57  
그게 첫 번째 열, 두 번째 열이에요.

44:06  
그럼 전체 열공간은 뭐죠?

44:13  
이 두 벡터의 모든 선형결합을 생각하는 겁니다.

44:19  
전체 공간을 얻을까요? 아니면 평면일까요?

44:24  
직선보다는 많고, 0 벡터보다는 많지만,  
0 벡터도 포함돼 있어요.

44:31  
두 벡터의 선형결합을 모두 취하면 R³ 전체가 되진 않겠죠.

44:39  
그럼 무엇이 될까요?

44:46  
하나의 직선도 채워지고, 다른 직선도 채워지고,  
그 사이의 모든 벡터들도 채워집니다.

44:52  
왜냐하면 한쪽에서 나온 벡터, 다른 쪽에서 나온 벡터를 더할 수 있으니까요.

44:58  
결국 **평면**이 나오는 거예요.

45:05  
그리고 그건 **원점을 지나는 평면**입니다.

45:10  
이 두 벡터, (1,2,4)와 (3,3,1)을 가지고

45:17  
모든 선형결합을 만들면 하나의 평면을 채우게 돼요. 꼭 생각해 보세요.

45:25  
이 그림을 머릿속에 그릴 수 있어야 해요.  
R³에서는 그게 가능하죠. 왜냐하면

45:31  
곧 R¹⁰에서도 이걸 해야 하거든요.  
예를 들어, R¹⁰에서 벡터 5개를 조합한다고 하면

45:40  
그 결과는 뭘까요?  
신만 알겠죠. 어쨌든 부분공간 하나가 나옵니다.

45:46  
그 벡터들은 전부 성분이 10개고,  
우리는 그 선형결합을 생각하는 거예요.

45:52  
R⁵는 아니에요.  
왜냐하면 벡터들의 성분 수가 10개니까요.

45:58  
대신, 원점을 지나는 **5차원의 평면(flat)** 같은 게 나올 수도 있어요.

46:05  
물론 그 5개 벡터가 모두 같은 직선 위에 있다면,  
우리가 얻는 건 그 직선 하나뿐이에요.

46:12  
이처럼 가능성은 다양해요.  
결국은 벡터들이 어떤 형태이냐에 달렸어요.

46:21  
방금도 열 두 개가 같은 직선 위에 있었다면,  
열공간도 직선이 됐겠죠.

46:28  
하지만 여기선 평면이 됐어요. 좋아요.

46:35  
여기서 오늘은 마무리할게요.  
이게 핵심 개념입니다 —  
행렬로부터 부분공간을 만드는 훌륭한 예제예요.

46:44  
행렬의 열을 가져오고, 그 선형결합을 모두 취하면

46:51  
그게 바로 열공간입니다.

46:57  
그리고 이건 선형대수를 더 높은 관점에서 보는 출발점이죠.

47:04  
다음 강의에서는 A와 Ax=b를 다시 살펴볼 거예요.

47:10  
이 새로운 언어 — 벡터공간과 열공간의 언어로  
Ax=b를 어떻게 이해할 수 있을지 말이죠.

47:22  
그리고 다른 부분공간들도 있어요.  
열공간이 가장 대표적인 것이고, 나머지는 이후에 다룰 거예요.

47:30  
좋습니다. 감사합니다.
