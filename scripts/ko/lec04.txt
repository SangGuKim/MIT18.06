0:00
준비됐나요? 좋아요, 이제 제가 시작해도 될까요.

0:11
1분 안에 촬영 시작할 준비가 되었어요.

0:23
그가 손을 들어 신호를 줄 거예요. 제가 시작할 타이밍이죠.

0:38
잠깐만요, 그들 좀 진정하게 놔두죠. 자, 여러분.

0:50
좋아요, 시작하라는 신호를 주세요. 그럼 제가 시작할게요.

1:02
좋아요, 이번 강의는 선형대수학(Linear Algebra), 네 번째 강의예요.
우선 지난 시간에 하기로 했던 것 중 하나부터 해야겠어요.
곱의 역행렬(inverse of a product)이 뭘까요?

1:19
두 행렬을 곱하고 나서 각 행렬의 역행렬을 알고 있을 때,
A 곱하기 B의 역행렬은 어떻게 구할 수 있을까요?

1:25
A나 B 각각의 역행렬은 알고 있다고 칩시다.
그렇다면 A 곱하기 B의 역행렬은 어떤 행렬일까요?

1:34
즉, AB에 어떤 행렬을 곱해야 항등행렬(identity)이 될까요?

1:44
이건 간단하지만 아주 기본적인 거예요.
그리고 이걸 이용해서...

1:52
우리는 여러 개의 소거 행렬(elimination matrix)을 곱해서 나오는 형태를 보게 될 거예요.

1:59
그리고 오늘 강의의 최종 목표는 소거(elimination)를 위한 멋진 공식이에요.

2:07
다시 말해서, 가우스 소거법(Gaussian elimination)을 멋지게 표현하는 방식이에요.

2:18
우리는 A에서 U로 가는 과정을 소거로 얻는다는 건 알고 있어요.
과정도 알고 있고요. 그런데 이제 제대로 바라보는 법을 알게 되는 거예요.
A는 L 곱하기 U라는 식이에요. 그게 오늘의 핵심이에요.

2:32
자, 그럼 쉬운 것부터 시작해도 될까요?

2:37
A가 가역행렬(invertible)이라고 해봅시다.
물론 어떤 행렬이 가역인지 아닌지는 중요한 질문이지만,
지금은 A와 B 둘 다 가역이라고 해볼게요.

2:51
그렇다면 AB의 역행렬은 어떤 행렬일까요?

2:58
그게 바로 질문이죠. AB의 역행렬은 뭘까요?
각각의 역행렬을 곱하는 걸까요?

3:03
맞아요. A의 역행렬과 B의 역행렬을 곱해요.

3:08
하지만 어떤 순서로 곱할까요? 역순이에요. 왜 그런지 볼게요.

3:14
정답은 B의 역행렬 곱하기 A의 역행렬이에요.

3:20
그게 바로 우리가 찾는 역행렬이에요.
AB 곱하기 그 행렬을 계산해보면 항등행렬이 나오죠.

3:30
왜 그런지 다시 한번 볼게요. 괄호 위치는 바꿀 수 있어요.
사실 괄호 없이도 곱셈을 마음대로 할 수 있어요.

3:42
그렇다면 어떤 곱셈을 먼저 해야 할까요?
B 곱하기 B의 역행렬이죠.

3:48
그 결과는 항등행렬이에요.
그 다음 A 곱하기 항등행렬은 A가 되고,
A 곱하기 A의 역행렬은 다시 항등행렬이 돼요.

4:01
책에 나오는 멍청한 예제가 왜 있는지 이해가 되시겠죠.

4:06
왜 역행렬은 항상 역순으로 곱해야 할까요?

4:12
예를 들어 신발을 벗고 양말을 벗는다면,
역으로 할 땐 양말을 먼저 신고 그다음에 신발을 신어야 하잖아요.

4:26
죄송해요, 이 비유가 녹화되다니...

4:31
물론 다른 방향도 확인해봐야 해요.
B의 역행렬, A의 역행렬 곱하기 AB를 하면

4:43
이번에는 역행렬끼리 곱해서 항등행렬이 되고,
그게 다시 줄어들어서 결국 항등행렬이 돼요.

4:48
좋아요. 이렇게 해서 역행렬은 끝났어요.

4:56
이왕 하는 김에 전치(transpose)도 해볼게요.
다음 강의에서 전치가 많이 나올 거라서요.

5:05
지금은 정사각형 가역행렬(square invertible matrix)을 이야기하고 있어요.
이걸 전치시키면, 그 역행렬은 뭘까요?

5:14
좋은 공식이 있어요. 이렇게 시작해 볼게요.
A 곱하기 A의 역행렬은 항등행렬이죠.

5:23
이 식의 양쪽을 전치해봅시다.

5:30
그러면 전치가 등장하겠죠.
항등행렬을 전치하면 뭐가 될까요?

5:39
항등행렬 그대로예요.
왜냐하면 항등행렬은 대칭행렬(symmetric)이기 때문에,
전치해도 그대로예요.

5:44
A와 A의 역행렬의 곱을 전치하면,
각각 전치한 다음 곱해야 하는데, 그때 순서가 바뀌어야 해요.

6:07
결국 (A의 역행렬의 전치) 곱하기 (A의 전치) = 항등행렬이 돼요.

6:17
이 식은 아까 식에서 바로 나왔고,
이제 우리가 궁금했던 걸 알 수 있죠.
즉, A를 전치했을 때 그 역행렬은 뭐냐?

6:26
답은 A의 역행렬을 전치한 거예요.

6:45
A의 전치의 역행렬은
A의 역행렬을 전치한 것입니다.

6:52
이건 정말 좋은 결과니까
크게 표시해둘게요.

7:07
A의 전치의 역행렬이 궁금하면,
A의 역행렬을 전치하면 된다는 거예요.
즉, 전치와 역행렬은 순서를 바꿔도 된다는 뜻이죠.

7:26
좋아요. 이런 기본적인 사실들을 이제 활용할 수 있어요.

7:31
이걸 활용해서 이제 소거(elimination)를 제대로 살펴보겠습니다.

7:40
사실 소거의 핵심은,
행렬이 가지고 있는 정보를 이해하는 가장 좋은 방법이라는 거예요.
A = LU는 가장 기본적인 행렬 분해(factorization)예요.

8:04
여러분이 이 강의가 전부 소거에 관한 거라고 생각할까봐 걱정이 돼요.

8:15
그냥 행 연산(row operation)일 뿐이라고 생각하지 마세요.

8:21
우리는 그 이상을 배울 거예요.
하지만 그 전에 해야 할 적절한 대수학이에요.

8:32
이제 거의 끝났지만,
정돈된 형태로 정리하고 싶어요.

8:40
정돈된 형태는 행렬 형식(matrix form)이에요.
행렬 A가 있다고 하고, 좋은 행렬이라고 해볼게요.
소거가 가능하고, 행 교환(row exchange)은 없다고 가정해요.

8:54
즉, 피벗(pivot)은 모두 괜찮고,
피벗 위치에 0이 없어요.

8:59
결국 도달하는 건 U예요.  
즉, A에서 U로 가는 거죠.

9:06
그 둘 사이에는 어떤 관계가 있을까요?

9:13
학생: 0, 1, 0이요? A는 U와 어떤 관계인가요?

9:19
이 관계를 나타내는 행렬 L이 있어요.

9:25
먼저 2x2 행렬로 해볼게요.

9:34
A를 간단히 정해보죠.
2, 8, 그리고 1, 7이라고 해볼게요.
첫 피벗은 2고, 계수는 4가 되겠죠.

9:54
여기에 4를 넣으면 안 돼요. 그러면 두 번째 피벗이 없어지고,
행렬이 특이행렬(singular)이 돼서 문제가 생기죠.

10:02
대신 7을 넣을게요.

10:08
이제 여기에 소거 행렬을 곱해볼게요.

10:15
정확히 말하면 E21이에요.
(두 번째 행의 첫 번째 원소를 0으로 만들기 위해)

10:31
곱하면 한 번에 U가 나와요. 2x2 행렬이니까요.

10:40
두 번째 행에서 첫 번째 값을 0으로 만들고,
나머지는 3이 되겠죠. 그게 U예요.

10:46
그 작업을 한 행렬은 뭐였을까요?

10:52
소거 행렬 E21은
1, 0 / -4, 1 이에요.

10:58
좋아요. 이걸 보면 지금부터 하려는 것과 뭐가 다른지 알 수 있어요.
지금부터 하려는 건 A가 왼쪽에 나오고,
다른 행렬들이 오른쪽에 나오도록 하는 거예요.

11:17
이제 A = LU 형태로 만들어볼게요.

11:24
A는 여전히 2, 1 / 8, 7 이고,
U는 2, 1 / 0, 3 이에요.

11:36
그렇다면 L은 뭐일까요?

11:42
먼저 L은 E 행렬의 역행렬이에요.
이걸 곱하면 왼쪽이 항등행렬이 되고,
그 역행렬이 나타나서 L이라고 부를 수 있어요.

12:00
소거 행렬은 역행렬 구하기가 정말 쉬워요.

12:09
이 행렬의 역행렬은 1 0 4 1이에요. 실제로는 부호가 반대인 거죠.

12:21
STRANG: 0 1 0. 부호가 바뀐 거예요. 좋아요. 우리가 숫자를 제대로 했다면 이게 맞는 거예요.

12:29
이 식은 맞는 거예요. 첫 번째 행은 맞고, 첫 번째 행에 4를 곱해서 두 번째 행에 더하면 8 7이 되죠. 좋아요. 간단한 2x2예요.

12:43
그렇지만 우리가 가려는 형태가 여기에 이미 드러나 있어요.

12:49
보여주죠. L은 왜 L일까요? 왜 문자 L을 썼을까요?

12:54
U가 상삼각행렬(upper triangular)을 의미했다면, L은 당연히 하삼각행렬(lower triangular)이에요.

13:01
그리고 실제로는 대각선(diagonal)에 1이 들어 있어요. 반면에 U에는 피벗(pivot)들이 들어 있죠.

13:07
가끔은 피벗만 따로 떼어내고 싶을 때가 있어요.

13:16
그러니까 이렇게 쓸 수도 있다는 걸 잠깐 언급하고 싶어요.

13:22
예를 들어 이 행렬을 1 0 4 1이라고 쓰고요.  
그다음 피벗만 따로 분리한 행렬을 곱해볼 수 있어요.

13:28
예를 들면 대각 행렬(diagonal matrix)로 2 3. 그게 피벗들이에요.

13:34
그럼 나머지는 여기에 남게 되죠. 그럼 뭐가 남았을까요?

13:41
첫 번째 행을 2로 나눠서 2를 떼어내면 1과 1/2이 남고,

13:49
두 번째 행을 3으로 나눠서 3을 떼어내면 1이 남아요. 그럼 그 값은 어디에 넣을까요?

13:58
이걸 L과 U라고 했을 때, 이건 L D 또는 pivot U라고 부를 수 있어요.

14:06
이제 좀 더 균형 잡힌 형태가 되었어요. 여기에도 대각선에 1이 있고, 저기에도 있어요.

14:11
그리고 가운데에는 대각 행렬이 있어요. 둘 다 괜찮은 방식이에요.

14:19
Matlab은 둘 중 어느 쪽이든 출력해줄 거예요. 저는 기본적으로 LU 쪽을 따를 거예요.

14:26
자, 이제 2x2보다 더 큰 걸 생각해봐야겠네요.

14:32
방금 건 그냥 쉬운 연습문제였어요. 사실 이건 마이너스였고, 저건 플러스였죠.

14:41
그게 유일한 차이였어요.

14:47
하지만 3x3이 되면

14:52
좀 더 중요한 차이가 생겨요. 그걸 보여드릴게요.

14:58
이제 3x3으로 올라가 봅시다. 어떤 행렬 A가 있다고 할게요.

15:06
이제 이 행렬이 3x3이라고 생각해보죠.

15:12
지금은 숫자는 쓰지 않을게요. 첫 번째 소거 단계는 뭐였죠?

15:17
처음 곱하는 행렬은 어떤 이름일까요?

15:23
E21이에요. 첫 단계는 두 번째 행 첫 번째 원소를 0으로 만드는 거니까요.

15:30
맞죠? 두 번째 행은 0 0 1이 되겠고, 세 번째 행도 그렇고요.

15:39
그 다음 단계는 세 번째 행 첫 번째 원소를 0으로 만드는 거예요.

15:45
마지막 단계는 세 번째 행 두 번째 원소를 0으로 만드는 거죠.

15:51
그게 바로 소거고, 그 결과가 U가 되는 거예요.

15:59
여기서도 행 교환(row exchange)은 없다고 가정합니다.

16:05
좋은 케이스, 일반적인 케이스를 다루는 거예요. 행 교환 없이 진행할 수 있는 경우죠.

16:14
그런데 저는 이 모든 작업을 오른쪽으로 옮기고 싶어요. 그게 지금 이야기하고자 하는 핵심이에요.

16:21
이걸 전부 곱하면 어떤 행렬 E가 되겠죠.

16:31
하지만 그걸 오른쪽으로 옮기고 싶어요. 그러려면 역행렬이 필요하죠.

16:39
그래서 A와 U 사이에는 어떤 관계가 있을까요?

16:44
지금은 세 개의 행렬이 연달아 곱해져 있어요.

16:50
그 각각은 역행렬 구하기가 쉽죠.

16:57
그런데 문제는 전체를 한 번에 역행렬로 만들 수 있느냐는 거예요.

17:04
우리는 각각 따로 역행렬을 구할 수 있고,

17:11
그 역순으로 곱하면 전체 역행렬이 되죠. 그러면 뭐가 먼저 올까요?

17:11
E32의 역행렬이에요. 먼저 왼쪽에서 곱하면 그게 U 옆으로 오겠죠.

17:19
그다음엔 E31의 역행렬이 오고,

17:27
마지막으로 남는 건 E21의 역행렬이에요. 그게 바로 L이에요.

17:35
그래서 A는 L U. L은 역행렬들의 곱이에요.

17:43
이제 궁금한 건, 왜 이 쪽이 역행렬을 선호하는가 하는 거예요.

17:50
왜 이쪽 곱이 더 나은 걸까요?

17:58
이 곱이 더 좋은 이유를 설명해볼게요.

18:03
일반적인 예를 하나 들어보죠. 전형적인 케이스예요.

18:09
3x3에서 그 차이를 볼 수 있어요.

18:15
2x2에서는 E가 하나뿐이라 문제될 게 없었죠. 하지만 이젠 3x3이에요.

18:22
예를 들어 E21에 -2가 들어있다고 해볼게요.

18:34
그리고 E31은 단위행렬(identity)이라고 해볼게요. 몇 개만으로 포인트를 전달할 수 있을 거예요.

18:51
E32는 -5와 1이라고 해볼게요. 이런 게 전형적인 경우예요.

18:56
3행 1열에 이미 0이 있었다면 E31은 필요 없었겠죠.

19:03
이 정도면 제 말이 전달될까요?

19:10
곱을 직접 해볼게요. 이건 좋은 연습이에요.

19:25
이 행렬들을 곱해보면 위쪽 삼각은 어떻게 될까요?

19:32
전부 0이에요. 이 곱을 하면 대각선엔 1이 나오고, 그 위는 전부 0이 돼요.

19:39
왜냐하면 아래 행에서 위 행을 빼는 구조이기 때문이에요.

19:47
그래서 위로 이동하는 값은 없어요. 이전의 가우스-조르당(Gauss-Jordan)과는 달라요.

19:52
자, 이제 이 -2, 1, 0... 여기 있는 이 숫자는 뭐였죠?

20:08
그 숫자는 10이에요. 그리고 이건...

20:16
여기는 뭐가 들어갈까요? 3행과 2열을 곱한 결과는 -5 같네요.

20:21
그 10이죠.

20:28
그 10은 어떻게 생긴 걸까요? 저는 저 숫자가 마음에 안 들어요. 물론 지우고 싶진 않아요.

20:34
왜냐하면 맞는 값이긴 하니까요. 하지만 원하던 결과는 아니에요.

20:43
그 10은 어떻게 생겼냐면, 먼저 1행에서 2배를 빼서 2행을 만들고,

20:49
그 2행에서 다시 5배를 빼서 3행을 만들었기 때문이에요.

20:58
그 순서대로 했기 때문에, 1행이 3행에 영향을 주게 된 거예요.

21:04
결국 1행에서 2배를 뺐고, 그게 다시 5배가 빠졌으니까

21:10
전체적으로는 1행의 10배가 3행에 섞여 들어간 거예요.

21:20
이제 제가 말하고 싶은 건 반대 방향이에요. 역행렬을 이용한 거죠.

21:29
이제 역순으로 가볼게요. 순서를 반대로요.

21:36
이제 이건 왼쪽에서 곱하는 E 행렬이에요.

21:44
이제 역순으로 역행렬을 곱해볼게요.

21:50
그러면 가장 먼저 나올 것은 E21의 역행렬이에요.

21:57
E21의 역행렬은 부호만 바꿔주면 돼요.

22:06
각 행렬마다 원래 빼던 값을 다시 더해주면 되니까요.

22:15
이제 그다음 것도 역행렬로 만들면 돼요.

22:23
역행렬은 같은 형태에 부호만 바뀌는 거니까, 5를 더해주면 되죠.

22:29
이제 곱셈을 해볼게요. 이번엔 결과가 좋아야겠네요.

22:38
지금까지는 잘하고 있죠? 네, 괜찮아요.

22:44
곱셈을 해볼게요. 첫 번째 행은 1 0 0이 될 거예요.

22:50
두 번째 행은 2 1 0이겠죠.

22:57
그래서 2 1 0이 되고, 세 번째 행은?

23:05
세 번째 행은 뭐가 나올까요?

23:14
읽어주세요, 세 번째 행은?

23:23
이게 바로 제 행렬 L이에요. 이건 U의 왼쪽에 곱해지는 거죠.

23:32
제가 말한 뜻은 이런 거예요.

23:38
그냥 왼쪽이라고만 하지 말고, 정확히 다시 써볼게요.

23:45
E 곱하기 A는 U, 반면 A는 L 곱하기 U예요.

23:54
이제 말로 설명드릴게요.

23:59
L을 만들기 위한 행렬의 순서는 자연스러운 순서예요.  
2와 5가 서로 간섭해서 10 같은 이상한 숫자를 만들지 않아요.

24:08
그 순서대로 하면, 계수(multiplier)들은 L 행렬 안에 자연스럽게 들어가요.

24:20
중요한 점은 이거예요 — L을 알고 싶다면, 별도로 계산할 게 없다는 거예요.

24:28
우리는 그때 사용했던 곱셈 계수(multiplier)만 기록해두면 돼요.

24:39
그게 L이 되는 거죠. 자, 다시 써볼게요.

24:46
이게 바로 A = LU예요. 만약 행 교환(row exchange)이 없었다면,

25:04
우리가 각 단계에서 행을 곱하고 뺄 때 사용한 그 계수들이

25:10
그대로 L에 들어가게 돼요.

25:21
좋아요, L이라는 건 — 이런 식으로 소거(elimination)를 바라보는 거예요.

25:36
소거 과정을 따라가다 보면, 제대로 한다면

25:43
LU를 만들어가는 과정에서 A는 버릴 수 있어요.

25:50
생각해보면, A의 두 번째 행을 끝냈을 때

26:02
우리는 U의 새로운 두 번째 행을 만들었고, 그걸 저장해둬야 해요.

26:07
그리고 사용한 곱셈 계수들도 저장해야 하죠. 그게 하나의 사이클처럼 되는 거예요.

26:13
그리고 나면 A는 잊어도 돼요. 왜냐하면 모든 정보가 L과 U 안에 담겨 있으니까요.

26:22
이 순간이 바로 새로운 통찰이 나오는 지점일 수 있어요.

26:30
소거를 행렬 형태(matrix form)로 진행하면요.

26:35
그러니까, E들의 곱이라는 것은 —

26:43
우리는 E들의 곱이 정확히 어떤 행렬인지를 잘 볼 수 없어요. E 자체는 별로 보기 좋은 행렬이 아니에요.

26:50
하지만 그것들을 반대 순서로 다른 쪽(오른쪽)에 놓으면,

26:55
그때 L이 제대로 나와요. 좋아요 — 오늘은 약간 실용적인 날이에요.

27:03
우리 함께 생각해봅시다. 소거 과정은 계산적으로 얼마나 복잡할까요?

27:14
얼마나 많은 연산(operation)이 필요할까요? 이건 사실 오늘 계획에 없던 주제인데 나왔네요.

27:29
n x n 행렬 A에 대해서요.

27:44
이건 매우 현실적인 질문이에요.

27:52
천 차원의 시스템을 1초 만에 풀 수 있을까요?

27:58
아니면 1분이나 1주일이 걸릴까요? 백만 차원짜리는 1초? 1시간? 1주일?

28:09
n x n이라면, 우리는 n이 클 때를 자주 다루게 돼요.

28:19
더 많은 정보를 담게 되고, 더 큰 행렬일수록 정확해지지만

28:27
계산량도 늘어나죠. 질문은 얼마나 늘어나느냐는 거예요. 100차원 행렬이라면요.

28:36
100 x 100 행렬이라고 해봅시다. n = 100이라고 놓고요.

28:41
이럴 때 몇 단계의 연산이 필요할까요?

28:49
실제로 우리가 해야 하는 연산은 몇 번일까요?

28:54
그리고 행렬에 좋은 위치에 0이 많다면 그만큼 연산이 줄어들어요.

29:00
그럴 땐 훨씬 빨라지겠죠. 모든 행이 바뀌게 되니까요. 그런데 지금은 첫 단계를 생각해보죠.

29:10
지금 A는 100 x 100 크기의 행렬이에요.

29:17
첫 단계는 —

29:24
그 열 아래쪽은 0으로 만들어지겠죠. 즉, 99 x 99 크기로 줄어드는 거예요.

29:35
그게 첫 번째 소거 단계예요. 2행이 위로, 3행이 위로 올라오는 거죠.

29:41
이렇게 100 x 100의 비어 있지 않은 행렬에서

29:46
첫 번째 피벗이 제 위치에 자리 잡고, 첫 행과 첫 열이 정리되기까지의 과정이죠.

29:54
자, 결국 이게 몇 단계가 필요했을까요? 지금 저는 이걸 감으로 잡으려는 중이에요.

30:01
이 연산의 총량은 n에 비례할까요? 전체 소거 연산의 수가요.

30:10
n에 비례하면, n이 100에서 200으로 두 배가 되면 시간도 두 배 걸릴까요?

30:18
아니면 제곱에 비례해서 4배 걸릴까요? 세제곱이면 8배?

30:25
아니면 n 팩토리얼만큼? 그럼 100배, 101배, 102배 이런 식으로 늘어나겠죠.

30:31
실제로 계산 비용이 어느 정도일지는 알고 있어야 해요.

30:38
자, 질문을 다시 정리해볼게요. 연산량이 N에 비례할까요? N 제곱? N 세제곱?

30:47
아니면 더 높은 차수일까요? N 팩토리얼처럼 단계마다 계속 곱해지는 구조일까요?

30:57
정답은 어떤 걸까요?

31:02
제가 이걸 알 수 있는 방법은 하나뿐이에요. 실제로 어떤 연산을 하는지 생각해보는 거예요.

31:08
좋아요. 여기서 연산량은 어떻게 될까요?

31:17
연산 하나란 게 뭐냐고요? 덧셈이나 —

31:27
그래요. 별거 아니죠. 덧셈, 뺄셈, 곱셈, 나눗셈 같은 걸 말하는 거예요.

31:33
그리고 실제로 우리가 계속 하고 있는 연산은 뭘까요?

31:42
1행에 어떤 계수 L을 곱하고 6행에서 빼는 거죠. 그럼 실제로 어떤 일이 일어날까요?

31:56
곱셈을 하고, 뺄셈을 하게 되죠.

32:03
그걸 하나의 연산으로 쳐도 될까요?

32:10
아니면 따로 세는 게 나을 수도 있어요. 일반적으로는 곱셈 + 뺄셈이 한 묶음이죠.

32:19
그 두 개를 합쳐서 하나로 친다면, 결과는...

32:26
뭐랄까... 나중에 곱셈과 뺄셈을 따로 계산한다면 횟수는 두 배가 되겠죠.

32:32
하지만 지금은 그걸 합쳐서 봐요. 그럼 이 과정에서 우리는 몇 번이나 그걸 하게 될까요?

32:37
32:44
대략적으로 보면 —

32:51
이 단계에서 여기까지 가는 데 얼마나 많은 연산이 필요할까요? 하나의 시각은 이거예요.

32:57
이 숫자들은 전부 바뀌어야 해요. 첫 번째 행은 바뀌지 않아요.

33:03
하지만 나머지 행들은 전부 바뀌어요. 이 단계에서는요.

33:10
그럼 대략 비용이 얼마나 될까요? 저는 대충 100 제곱 정도라고 말하겠어요.

33:17
첫 번째 행까지 바꿨다면 정확히 100 제곱이었겠죠.

33:23
왜냐하면 여기 있는 숫자 개수가 딱 그 정도예요.

33:30
100 x 100 = 10,000개가 있고, 첫 번째 행만 빼고 다 바뀌었어요.

33:39
그래서 대략 100 제곱이라고 할 수 있어요. 좋아요. 그다음 단계는요?

33:45
이제 첫 번째 행은 손댈 필요 없어요.

33:51
두 번째 행도 마찬가지예요. 그리고 여긴 이미 0이죠.

33:58
그럼 두 번째 단계에서는? 같이 생각해봐요. 대략 연산량이 얼마나 될까요?

34:05
첫 번째 단계가 100 제곱 정도였다면, 이 단계는 —

34:12
이 부분을 처리해서 원하는 걸 얻는 데 드는 연산량은?

34:18
얼마나 될까요?

34:26
대략 99 제곱이겠죠. 또는 99 곱하기 98 정도. 어쨌든 줄어들어요.

34:31
문제가 점점 작아지고 있으니까요. 약 99 제곱 정도예요.

34:37
그리고 다음 단계는 98 제곱, 그다음은 97 제곱... 마지막엔 1 제곱까지 가요.

34:44
작은 숫자들은 마지막에 나오고, 큰 숫자들은 앞쪽에 몰려 있어요.

34:51
그래서 전체 연산량은 대략 n 제곱 + 그 이하 값들의 합이에요.

34:58
지금 n은 100이라고 했죠? 처음에는 100 제곱, 그다음은 99 제곱...

35:06
그다음은 98 제곱... 마지막은 3 제곱, 2 제곱, 1 제곱까지요.

35:13
35:18
그걸 저렇게 꽉 끼게 써버리면 안 되죠. 다시 써볼게요. 전체 합은 N 제곱 + N-1 제곱 +

35:31
+ ... + 1 제곱까지요.

35:36
꽤 괜찮은 계산 방식이에요. 아주 작은 연산까지 다 셌다고는 못하지만,

35:45
최고차항은 제대로 잡았어요.

35:52
그걸 다 더하면 뭐가 나올까요? 이제 이 질문의 핵심에 가까워지고 있어요.

36:02
연산량, 즉 이 A 행렬 왼쪽에서 시작해서

36:09
최종적으로 U로 가는 데 드는 연산량이에요.

36:15
여기서 — 그럼 이 후보 중에서 뭐가 맞을까요?

36:20
100 제곱 + 99 제곱 + 98 제곱... 2 제곱 + 1 제곱을 더하면

36:34
결과가 대략 뭐쯤 될까요? 이제 이걸 명확히 해보죠.

36:43
이게 N인가요? 절대 아니죠. N 팩토리얼인가요?

36:50
아니에요. 그랬다면 큰일 나죠. 결정식(determinant) 계산은 팩토리얼이죠.

36:57
결정식은 계산 비용이 크기 때문에 마이너스 점수 줄게요.

37:04
좋아요, 정답은 이겁니다.

37:12
정답은 이 차수예요 — n의 세제곱(n³)이요. 이 합 안에는 n개의 항이 있죠?

37:21
이 합 안에 n개의 항이 있고, 가장 큰 항은 n의 제곱(n²)이에요.  
그러니까 최악의 경우는 n³일 수 있지만,

37:29
실제로 그렇게까지 나쁘진 않아요. 대략 n³의 1/3 정도예요.

37:35
즉, 약 1/3 n³이라는 게 마법 같은 연산 수치예요.

37:40
이 1/3이라는 값은, 숫자들이 점점 작아진다는 사실을 반영한 거예요.

37:57
만약 줄어들지 않았다면, n개의 항 × n² 해서 정확히 n³이 됐겠죠.

38:03
하지만 실제로는 숫자가 줄어들어요 — 예를 들어 2행과 1행이 3행으로 내려오는 식이죠.

38:09
혹시 1/3이 어디서 나오는지 기억하시나요 — 미적분학(calculus)을 잠깐 언급해도 될까요.

38:15
자, 이제 미적분 얘기를 해도 돼요. 통합(integration)도요. 오늘 1분만요, 그리고 몇 주간은 안 할게요.

38:23
18.01(기초 미적분)을 싫어하는 건 아닌데, 전 18.06(선형대수학)이 더 좋아요.

38:28
좋아요. 그래서, 그럼 이런 걸 떠올려보세요.

38:38
만약 이게 미적분이었다면, 합(sum)을 하지 않고 적분(integral)을 했을 거예요.

38:46
x²을 적분하면 결과는 1/3 x³이 되죠.

38:52
이걸 x²에 대해 1부터 N까지 적분한다면, 결과는 1/3 N³이 돼요.

39:00
이건 합에도 적용돼요. 왜냐하면 이게 바로 미적분의 핵심이니까요.

39:09
미적분의 핵심은 이렇죠 — 아, 다 설명하진 않을게요. 여러분은 알고 있을 테니까요.

39:18
미적분은 합을 연속적으로 한 것이고,

39:24
대수학(algebra)은 이산적(discrete)이죠. 결론은, 연산량은 1/3 n³이라는 거예요.

39:30
이제 한 가지만 더 이야기할게요. 연산에 관해서요. 오른쪽은 어떤가요?

39:37
방금 말한 건 왼쪽, 즉 A에 관한 연산량이었어요.

39:44
우리가 계산하고 있는 행렬 A에 대한 거였죠. 그런데, 우리가 곁에 두고 있는 열 벡터 b에 대한 연산은 어떤가요?

39:52
b는 연산량이 훨씬 적어요. 왜냐하면 단지 한 열뿐이니까요.

40:00
우리는 그 열을 소거 과정 전체에 걸쳐 유지하고,

40:07
그리고 나서 후방 대입(back substitution)을 하게 돼요. 그 결과는 n의 제곱, 즉 n²이에요.

40:14
오른쪽 열 하나당 드는 비용은 n²이에요. 이걸 여기 덧붙여 적을게요.

40:30
b의 비용은 n²이에요. 자, 보세요. 우리가 자주 겪는 경우는 이렇죠.

40:37
하나의 행렬 A가 있고, 여러 개의 오른쪽 열 벡터 b가 있는 경우요.

40:43
그럴 때는 A에 대해서만 높은 비용을 한 번 치르고,

40:50
LU 분해를 해두면, 이후 각각의 b는 저렴한 비용으로 처리할 수 있어요.

40:58
좋아요. 이로써 우리는 선형 방정식 시스템을 푸는

41:05
가장 기본적인 알고리즘을 다 다룬 셈이에요.

41:12
좋아요. 이제 행 교환(row exchanges)을 허용할 준비가 됐어요.

41:24
자, 그럼 오늘 배운 이 전체 이야기에서, 행 교환이 생긴다면 어떤 일이 벌어질까요?

41:30
언제 행 교환이 필요하죠?

41:38
피벗 위치에 0이 나올 때, 우리는 행 교환을 해야 해요.  
이제 마지막 파트로 넘어갈게요 — 이 장의 마지막 주제예요.

41:48
그건 전치(transpose)에 대한 건데, 우리는 이미 조금 다뤘죠.

41:56
이 섹션의 제목은요 — 제목을 말씀드리면, 또 다른 개념이 나와요.

42:04
"전치와 순열 (Transposes and Permutations)"이에요. 좋아요.

42:11
그럼 이제 순열(permutation)은 어디에 등장하는 걸까요?

42:16
이제 순열에 대해 조금 이야기해보죠. 여기 위에 적어볼게요 — 순열.

42:27
이건 행을 바꾸기 위해 필요한 행렬이에요.

42:35
어쩌면 두 번의 행 교환이 필요할 수도 있죠. 그런 행렬 하나 생각해볼 수 있을까요?

42:42
두 번의 행 교환이 필요하고, 결국 잘 끝나는 그런 행렬이요.

42:50
좋아요, 그냥 재미 삼아 해볼게요. 여기에 적어둘게요.

42:57
3×3 행렬로 해볼게요. 아니면, 그냥

43:03
3×3 순열 행렬(permutation matrix)을 전부 나열해볼까요? 좋은 집합이에요.

43:09
아무 행도 바꾸지 않는 행렬은 뭐가 있을까요?

43:16
항등행렬(identity)이 있겠네요.

43:22
그건 아무 일도 안 하는 순열 행렬이에요. 그럼 1행과 2행을 바꾸는 행렬은 뭐죠?

43:30
P12라고 하죠. 그건 — 0 1 0 —

43:42
1 0 0 — 맞아요. 항등행렬에서 1행과 2행만 바꾸면 돼요.

43:49
좋아요. 사실 이걸 — 네, 좀 지저분하게 쓰게 될 거예요. 괜찮아요.

43:55
그럼 모든 행 교환 행렬을 다 나열해봅시다.

44:02
어떤 것들이 있을까요? 항등행렬에서 행을 재배열할 수 있는 모든 경우예요.

44:10
총 몇 개가 있을까요? 3×3 순열 행렬은 몇 개일까요?

44:18
계속 가봅시다. 답이 나올 때까지요. 다음엔 뭐 할 건가요?

44:28
1행과 3행을 바꿀게요. 2는 그대로 두고요. 다음은요? 2행과 3행을 바꾸는 것도 있죠. 좋아요. 그럼 1 0 0은 그대로 두고 — 

44:50
3을 위로 올리고 2를 아래로 내릴 거예요.

44:56
좋아요. 이건 둘씩만 바꾸는 경우들이에요.

45:02
이 셋은 각각 두 개의 행만 바꿔요. 하지만 그 외의 경우도 있어요.

45:08
남은 게 뭐죠? 하나 더 있어요. 그건...

45:17
어디 보자. 뭐가 남았죠? 기억이 안 나네요.

45:23
학생: 0 0 1 인가요?

45:28
STRANG: 좋아요. 학생: 1 0 0요. STRANG: 1 0 0, 좋습니다.

45:37
0 1 0. 좋아요, 훌륭해요.

45:42
총 여섯 개가 나왔어요. 여섯 개의 P예요. 이건 꽤 괜찮은 집합이에요.

45:55
이 중 두 개를 곱하면 어떻게 될까요?

46:04
이 행렬 중 두 개를 곱하면,

46:12
결과에 대해 뭘 알 수 있을까요?

46:20
결과도 이 목록 중 하나예요. 행 교환을 한 번 하고,

46:33
다시 한 번 더 하면, 전체적으로는 행 교환을 한 거죠.

46:41
그래서 곱셈을 해도 — 뭐, 확실하진 않지만...

46:51
역행렬을 구하는 건, 그냥 행 교환을 되돌리는 거예요.

46:57
역행렬도 전부 이 안에 있어요. 이건 하나의 행렬 집합인데 —

47:03
곱해도 이 집합 안에 남아 있고,

47:08
역을 취해도 이 집합 안에 있어요. 사실, 이걸 '군(group)'이라고 부르죠.

47:15
6개의 행렬로 이루어진 군이에요. 역행렬은 어떨까요?

47:21
예를 들어, 이 행렬의 역행렬은요? 1행과 2행을 바꿨다면,

47:27
역행렬은 뭐죠? 빨리 말해보세요.

47:33
그 행렬의 역은 — 1행과 2행을 다시 바꾸면 되니까,

47:42
결국 같은 걸 다시 하면 원래대로 돌아가죠.

47:47
그러니까 그 행렬은 자기 자신이 역행렬이에요. 이것도 마찬가지일 거예요.

47:53
이건 아닐 수도 있어요 — 사실 이 둘은 서로의 역행렬일 거예요. 아, 맞다 — 

48:00
역행렬은 전치(transpose)예요. 순열 행렬의 특이한 점은,

48:08
역행렬이 바로 전치라는 점이에요. 마지막으로 — 4×4는 몇 개일까요?

48:16
4×4 순열 행렬은 총 몇 개일까요? 그럼 4×4로 가보죠.

48:22
총 몇 개의 P가 나올까요? 좋아요.

48:29
한번 맞혀보세요. 24개죠. 그렇죠, 24개의 P가 있어요.

48:38

48:44
좋아요.

48:51
우리는 이제 이 순열 행렬들을 갖고 있고,

49:29
다음 강의에서 이걸 사용할 거예요.
